"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotprompt";
exports.ids = ["vendor-chunks/dotprompt"];
exports.modules = {

/***/ "(action-browser)/./node_modules/dotprompt/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dotprompt/dist/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  Dotprompt: () => Dotprompt,\n  PicoschemaParser: () => PicoschemaParser,\n  picoschema: () => picoschema\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/dotprompt.ts\nvar Handlebars = __toESM(__webpack_require__(/*! handlebars */ \"(action-browser)/./node_modules/handlebars/lib/index.js\"));\n\n// src/helpers.ts\nvar helpers_exports = {};\n__export(helpers_exports, {\n  history: () => history,\n  ifEquals: () => ifEquals,\n  json: () => json,\n  media: () => media,\n  role: () => role,\n  section: () => section,\n  unlessEquals: () => unlessEquals\n});\nvar import_handlebars = __webpack_require__(/*! handlebars */ \"(action-browser)/./node_modules/handlebars/lib/index.js\");\nfunction json(serializable, options) {\n  return new import_handlebars.SafeString(\n    JSON.stringify(serializable, null, options.hash.indent || 0)\n  );\n}\nfunction role(role2) {\n  return new import_handlebars.SafeString(`<<<dotprompt:role:${role2}>>>`);\n}\nfunction history() {\n  return new import_handlebars.SafeString(\"<<<dotprompt:history>>>\");\n}\nfunction section(name) {\n  return new import_handlebars.SafeString(`<<<dotprompt:section ${name}>>>`);\n}\nfunction media(options) {\n  return new import_handlebars.SafeString(\n    `<<<dotprompt:media:url ${options.hash.url}${options.hash.contentType ? ` ${options.hash.contentType}` : \"\"}>>>`\n  );\n}\nfunction ifEquals(arg1, arg2, options) {\n  return arg1 === arg2 ? options.fn(this) : options.inverse(this);\n}\nfunction unlessEquals(arg1, arg2, options) {\n  return arg1 !== arg2 ? options.fn(this) : options.inverse(this);\n}\n\n// src/parse.ts\nvar import_yaml = __webpack_require__(/*! yaml */ \"(action-browser)/./node_modules/yaml/dist/index.js\");\nvar ROLE_MARKER_PREFIX = \"<<<dotprompt:role:\";\nvar HISTORY_MARKER_PREFIX = \"<<<dotprompt:history\";\nvar MEDIA_MARKER_PREFIX = \"<<<dotprompt:media:\";\nvar SECTION_MARKER_PREFIX = \"<<<dotprompt:section\";\nvar FRONTMATTER_AND_BODY_REGEX = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/;\nvar ROLE_AND_HISTORY_MARKER_REGEX = /(<<<dotprompt:(?:role:[a-z]+|history))>>>/g;\nvar MEDIA_AND_SECTION_MARKER_REGEX = /(<<<dotprompt:(?:media:url|section).*?)>>>/g;\nvar RESERVED_METADATA_KEYWORDS = [\n  // NOTE: KEEP SORTED\n  \"config\",\n  \"description\",\n  \"ext\",\n  \"input\",\n  \"model\",\n  \"name\",\n  \"output\",\n  \"raw\",\n  \"toolDefs\",\n  \"tools\",\n  \"variant\",\n  \"version\"\n];\nvar BASE_METADATA = {\n  ext: {},\n  metadata: {},\n  config: {}\n};\nfunction splitByRegex(source, regex) {\n  return source.split(regex).filter((s) => s.trim() !== \"\");\n}\nfunction splitByRoleAndHistoryMarkers(renderedString) {\n  return splitByRegex(renderedString, ROLE_AND_HISTORY_MARKER_REGEX);\n}\nfunction splitByMediaAndSectionMarkers(source) {\n  return splitByRegex(source, MEDIA_AND_SECTION_MARKER_REGEX);\n}\nfunction convertNamespacedEntryToNestedObject(key, value, obj = {}) {\n  const result = obj || {};\n  const lastDotIndex = key.lastIndexOf(\".\");\n  const ns = key.substring(0, lastDotIndex);\n  const field = key.substring(lastDotIndex + 1);\n  result[ns] = result[ns] || {};\n  result[ns][field] = value;\n  return result;\n}\nfunction extractFrontmatterAndBody(source) {\n  const match = source.match(FRONTMATTER_AND_BODY_REGEX);\n  if (match) {\n    const [, frontmatter, body] = match;\n    return { frontmatter, body };\n  }\n  return { frontmatter: \"\", body: \"\" };\n}\nfunction parseDocument(source) {\n  const { frontmatter, body } = extractFrontmatterAndBody(source);\n  if (frontmatter) {\n    try {\n      const parsedMetadata = (0, import_yaml.parse)(frontmatter);\n      const raw = { ...parsedMetadata };\n      const pruned = { ...BASE_METADATA };\n      const ext = {};\n      for (const k in raw) {\n        const key = k;\n        if (RESERVED_METADATA_KEYWORDS.includes(key)) {\n          pruned[key] = raw[key];\n        } else if (key.includes(\".\")) {\n          convertNamespacedEntryToNestedObject(key, raw[key], ext);\n        }\n      }\n      return { ...pruned, raw, ext, template: body.trim() };\n    } catch (error) {\n      console.error(\"Dotprompt: Error parsing YAML frontmatter:\", error);\n      return { ...BASE_METADATA, template: source.trim() };\n    }\n  }\n  return { ...BASE_METADATA, template: source };\n}\nfunction messageSourcesToMessages(messageSources) {\n  return messageSources.filter((ms) => ms.content || ms.source).map((m) => {\n    const out = {\n      role: m.role,\n      content: m.content || toParts(m.source || \"\")\n    };\n    if (m.metadata) {\n      out.metadata = m.metadata;\n    }\n    return out;\n  });\n}\nfunction transformMessagesToHistory(messages) {\n  return messages.map((m) => ({\n    ...m,\n    metadata: { ...m.metadata, purpose: \"history\" }\n  }));\n}\nfunction toMessages(renderedString, data) {\n  let currentMessage = { role: \"user\", source: \"\" };\n  const messageSources = [currentMessage];\n  for (const piece of splitByRoleAndHistoryMarkers(renderedString)) {\n    if (piece.startsWith(ROLE_MARKER_PREFIX)) {\n      const role2 = piece.substring(ROLE_MARKER_PREFIX.length);\n      if (currentMessage.source?.trim()) {\n        currentMessage = { role: role2, source: \"\" };\n        messageSources.push(currentMessage);\n      } else {\n        currentMessage.role = role2;\n      }\n    } else if (piece.startsWith(HISTORY_MARKER_PREFIX)) {\n      const historyMessages = transformMessagesToHistory(data?.messages ?? []);\n      if (historyMessages) {\n        messageSources.push(...historyMessages);\n      }\n      currentMessage = { role: \"model\", source: \"\" };\n      messageSources.push(currentMessage);\n    } else {\n      currentMessage.source += piece;\n    }\n  }\n  const messages = messageSourcesToMessages(messageSources);\n  return insertHistory(messages, data?.messages);\n}\nfunction messagesHaveHistory(messages) {\n  return messages.some((m) => m.metadata?.purpose === \"history\");\n}\nfunction insertHistory(messages, history2 = []) {\n  if (!history2 || messagesHaveHistory(messages)) {\n    return messages;\n  }\n  if (messages.length === 0) {\n    return history2;\n  }\n  const lastMessage = messages.at(-1);\n  if (lastMessage?.role === \"user\") {\n    const messagesWithoutLast = messages.slice(0, -1);\n    return [...messagesWithoutLast, ...history2, lastMessage];\n  }\n  return [...messages, ...history2];\n}\nfunction toParts(source) {\n  return splitByMediaAndSectionMarkers(source).map(parsePart);\n}\nfunction parsePart(piece) {\n  if (piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    return parseMediaPart(piece);\n  } else if (piece.startsWith(SECTION_MARKER_PREFIX)) {\n    return parseSectionPart(piece);\n  }\n  return parseTextPart(piece);\n}\nfunction parseMediaPart(piece) {\n  if (!piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    throw new Error(\"Invalid media piece\");\n  }\n  const [_, url, contentType] = piece.split(\" \");\n  const part = { media: { url } };\n  if (contentType) {\n    part.media.contentType = contentType;\n  }\n  return part;\n}\nfunction parseSectionPart(piece) {\n  if (!piece.startsWith(SECTION_MARKER_PREFIX)) {\n    throw new Error(\"Invalid section piece\");\n  }\n  const [_, sectionType] = piece.split(\" \");\n  return { metadata: { purpose: sectionType, pending: true } };\n}\nfunction parseTextPart(piece) {\n  return { text: piece };\n}\n\n// src/picoschema.ts\nvar JSON_SCHEMA_SCALAR_TYPES = [\n  \"string\",\n  \"boolean\",\n  \"null\",\n  \"number\",\n  \"integer\",\n  \"any\"\n];\nvar WILDCARD_PROPERTY_NAME = \"(*)\";\nasync function picoschema(schema, options) {\n  return new PicoschemaParser(options).parse(schema);\n}\nvar PicoschemaParser = class {\n  schemaResolver;\n  constructor(options) {\n    this.schemaResolver = options?.schemaResolver;\n  }\n  async mustResolveSchema(schemaName) {\n    if (!this.schemaResolver) {\n      throw new Error(`Picoschema: unsupported scalar type '${schemaName}'.`);\n    }\n    const val = await this.schemaResolver(schemaName);\n    if (!val) {\n      throw new Error(\n        `Picoschema: could not find schema with name '${schemaName}'`\n      );\n    }\n    return val;\n  }\n  async parse(schema) {\n    if (!schema) return null;\n    if (typeof schema === \"string\") {\n      const [type, description] = extractDescription(schema);\n      if (JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let out = { type };\n        if (description) out = { ...out, description };\n        return out;\n      }\n      const resolvedSchema = await this.mustResolveSchema(type);\n      return description ? { ...resolvedSchema, description } : resolvedSchema;\n    }\n    if ([...JSON_SCHEMA_SCALAR_TYPES, \"object\", \"array\"].includes(\n      schema?.type\n    )) {\n      return schema;\n    }\n    if (typeof schema?.properties === \"object\") {\n      return { ...schema, type: \"object\" };\n    }\n    return this.parsePico(schema);\n  }\n  async parsePico(obj, path = []) {\n    if (typeof obj === \"string\") {\n      const [type, description] = extractDescription(obj);\n      if (!JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let resolvedSchema = await this.mustResolveSchema(type);\n        if (description) resolvedSchema = { ...resolvedSchema, description };\n        return resolvedSchema;\n      }\n      if (type === \"any\") {\n        return description ? { description } : {};\n      }\n      return description ? { type, description } : { type };\n    } else if (typeof obj !== \"object\") {\n      throw new Error(\n        \"Picoschema: only consists of objects and strings. Got: \" + JSON.stringify(obj)\n      );\n    }\n    const schema = {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: false\n    };\n    for (const key in obj) {\n      if (key === WILDCARD_PROPERTY_NAME) {\n        schema.additionalProperties = await this.parsePico(obj[key], [\n          ...path,\n          key\n        ]);\n        continue;\n      }\n      const [name, typeInfo] = key.split(\"(\");\n      const isOptional = name.endsWith(\"?\");\n      const propertyName = isOptional ? name.slice(0, -1) : name;\n      if (!isOptional) {\n        schema.required.push(propertyName);\n      }\n      if (!typeInfo) {\n        const prop = { ...await this.parsePico(obj[key], [...path, key]) };\n        if (isOptional && typeof prop.type === \"string\") {\n          prop.type = [prop.type, \"null\"];\n        }\n        schema.properties[propertyName] = prop;\n        continue;\n      }\n      const [type, description] = extractDescription(\n        typeInfo.substring(0, typeInfo.length - 1)\n      );\n      if (type === \"array\") {\n        schema.properties[propertyName] = {\n          type: isOptional ? [\"array\", \"null\"] : \"array\",\n          items: await this.parsePico(obj[key], [...path, key])\n        };\n      } else if (type === \"object\") {\n        const prop = await this.parsePico(obj[key], [...path, key]);\n        if (isOptional) prop.type = [prop.type, \"null\"];\n        schema.properties[propertyName] = prop;\n      } else if (type === \"enum\") {\n        const prop = { enum: obj[key] };\n        if (isOptional && !prop.enum.includes(null)) prop.enum.push(null);\n        schema.properties[propertyName] = prop;\n      } else {\n        throw new Error(\n          \"Picoschema: parenthetical types must be 'object' or 'array', got: \" + type\n        );\n      }\n      if (description) {\n        schema.properties[propertyName].description = description;\n      }\n    }\n    if (!schema.required.length) delete schema.required;\n    return schema;\n  }\n};\nfunction extractDescription(input) {\n  if (!input.includes(\",\")) return [input, null];\n  const match = input.match(/(.*?), *(.*)$/);\n  return [match[1], match[2]];\n}\n\n// src/util.ts\nfunction removeUndefinedFields(obj) {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map((item) => removeUndefinedFields(item));\n  }\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== void 0) {\n      result[key] = removeUndefinedFields(value);\n    }\n  }\n  return result;\n}\n\n// src/dotprompt.ts\nvar Dotprompt = class {\n  handlebars;\n  knownHelpers = {};\n  defaultModel;\n  modelConfigs = {};\n  tools = {};\n  toolResolver;\n  schemas = {};\n  schemaResolver;\n  partialResolver;\n  store;\n  constructor(options) {\n    this.handlebars = Handlebars.noConflict();\n    this.modelConfigs = options?.modelConfigs || this.modelConfigs;\n    this.defaultModel = options?.defaultModel;\n    this.tools = options?.tools || {};\n    this.toolResolver = options?.toolResolver;\n    this.schemas = options?.schemas || {};\n    this.schemaResolver = options?.schemaResolver;\n    this.partialResolver = options?.partialResolver;\n    for (const key in helpers_exports) {\n      this.defineHelper(key, helpers_exports[key]);\n      this.handlebars.registerHelper(key, helpers_exports[key]);\n    }\n    if (options?.helpers) {\n      for (const key in options.helpers) {\n        this.defineHelper(key, options.helpers[key]);\n      }\n    }\n    if (options?.partials) {\n      for (const key in options.partials) {\n        this.definePartial(key, options.partials[key]);\n      }\n    }\n  }\n  /**\n   * Registers a helper function for use in templates.\n   *\n   * @param name The name of the helper function to register\n   * @param fn The helper function implementation\n   * @return This instance for method chaining\n   */\n  defineHelper(name, fn) {\n    this.handlebars.registerHelper(name, fn);\n    this.knownHelpers[name] = true;\n    return this;\n  }\n  /**\n   * Registers a partial template for use in other templates.\n   *\n   * @param name The name of the partial to register\n   * @param source The template source for the partial\n   * @return This instance for method chaining\n   */\n  definePartial(name, source) {\n    this.handlebars.registerPartial(name, source);\n    return this;\n  }\n  /**\n   * Registers a tool definition for use in prompts.\n   *\n   * @param def The tool definition to register\n   * @return This instance for method chaining\n   */\n  defineTool(def) {\n    this.tools[def.name] = def;\n    return this;\n  }\n  /**\n   * Parses a prompt template string into a structured ParsedPrompt object.\n   *\n   * @param source The template source string to parse\n   * @return A parsed prompt object with extracted metadata and template\n   */\n  parse(source) {\n    return parseDocument(source);\n  }\n  /**\n   * Renders a prompt template with the provided data.\n   *\n   * @param source The template source string to render\n   * @param data The data to use when rendering the template\n   * @param options Additional metadata and options for rendering\n   * @return A promise resolving to the rendered prompt\n   */\n  async render(source, data = {}, options) {\n    const renderer = await this.compile(source);\n    return renderer(data, options);\n  }\n  /**\n   * Processes schema definitions in picoschema format into standard JSON Schema.\n   *\n   * @param meta The prompt metadata containing schema definitions\n   * @return A promise resolving to the processed metadata with expanded schemas\n   */\n  async renderPicoschema(meta) {\n    if (!meta.output?.schema && !meta.input?.schema) {\n      return meta;\n    }\n    const newMeta = { ...meta };\n    if (meta.input?.schema) {\n      newMeta.input = {\n        ...meta.input,\n        schema: await picoschema(meta.input.schema, {\n          schemaResolver: this.wrappedSchemaResolver.bind(this)\n        })\n      };\n    }\n    if (meta.output?.schema) {\n      newMeta.output = {\n        ...meta.output,\n        schema: await picoschema(meta.output.schema, {\n          schemaResolver: this.wrappedSchemaResolver.bind(this)\n        })\n      };\n    }\n    return newMeta;\n  }\n  /**\n   * Resolves a schema name to its definition, using registered schemas or schema resolver.\n   *\n   * @param name The name of the schema to resolve\n   * @return A promise resolving to the schema definition or null if not found\n   */\n  async wrappedSchemaResolver(name) {\n    if (this.schemas[name]) {\n      return this.schemas[name];\n    }\n    if (this.schemaResolver) {\n      return await this.schemaResolver(name);\n    }\n    return null;\n  }\n  /**\n   * Merges multiple metadata objects together, resolving tools and schemas.\n   *\n   * @param base The base metadata object\n   * @param merges Additional metadata objects to merge into the base\n   * @return A promise resolving to the merged and processed metadata\n   */\n  async resolveMetadata(base, ...merges) {\n    let out = { ...base };\n    for (let i = 0; i < merges.length; i++) {\n      if (!merges[i]) continue;\n      const config = out.config || {};\n      out = { ...out, ...merges[i] };\n      out.config = { ...config, ...merges[i]?.config || {} };\n    }\n    const { template: _, ...outWithoutTemplate } = out;\n    out = outWithoutTemplate;\n    out = removeUndefinedFields(out);\n    out = await this.resolveTools(out);\n    out = await this.renderPicoschema(out);\n    return out;\n  }\n  /**\n   * Resolves tool names to their definitions using registered tools or tool resolver.\n   *\n   * @param base The metadata containing tool references to resolve\n   * @return A promise resolving to metadata with resolved tool definitions\n   */\n  async resolveTools(base) {\n    const out = { ...base };\n    if (out.tools) {\n      const outTools = [];\n      out.toolDefs = out.toolDefs || [];\n      await Promise.all(\n        out.tools.map(async (toolName) => {\n          if (this.tools[toolName]) {\n            if (out.toolDefs) {\n              out.toolDefs.push(this.tools[toolName]);\n            }\n          } else if (this.toolResolver) {\n            const resolvedTool = await this.toolResolver(toolName);\n            if (!resolvedTool) {\n              throw new Error(\n                `Dotprompt: Unable to resolve tool '${toolName}' to a recognized tool definition.`\n              );\n            }\n            if (out.toolDefs) {\n              out.toolDefs.push(resolvedTool);\n            }\n          } else {\n            outTools.push(toolName);\n          }\n        })\n      );\n      out.tools = outTools;\n    }\n    return out;\n  }\n  /**\n   * Identifies all partial references in a template.\n   *\n   * @param template The template to scan for partial references\n   * @return A set of partial names referenced in the template\n   */\n  identifyPartials(template) {\n    const ast = this.handlebars.parse(template);\n    const partials = /* @__PURE__ */ new Set();\n    const visitor = new class extends this.handlebars.Visitor {\n      // Visit partial statements and add their names to our set.\n      PartialStatement(partial) {\n        if (partial && typeof partial === \"object\" && \"name\" in partial && partial.name && typeof partial.name === \"object\" && \"original\" in partial.name && typeof partial.name.original === \"string\") {\n          partials.add(partial.name.original);\n        }\n      }\n    }();\n    visitor.accept(ast);\n    return partials;\n  }\n  /**\n   * Resolves and registers all partials referenced in a template.\n   *\n   * @param template The template containing partial references\n   * @return A promise that resolves when all partials are registered\n   */\n  async resolvePartials(template) {\n    if (!this.partialResolver && !this.store) {\n      return;\n    }\n    const partials = this.identifyPartials(template);\n    await Promise.all(\n      Array.from(partials).map(async (name) => {\n        if (!this.handlebars.partials[name]) {\n          let content = null;\n          if (this.partialResolver) {\n            content = await this.partialResolver(name);\n          }\n          if (!content && this.store) {\n            const partial = await this.store.loadPartial(name);\n            content = partial?.source;\n          }\n          if (content) {\n            this.definePartial(name, content);\n            await this.resolvePartials(content);\n          }\n        }\n      })\n    );\n  }\n  /**\n   * Compiles a template into a reusable function for rendering prompts.\n   *\n   * @param source The template source or parsed prompt to compile\n   * @param additionalMetadata Additional metadata to include in the compiled template\n   * @return A promise resolving to a function for rendering the template\n   */\n  async compile(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    if (additionalMetadata) {\n      parsedSource = { ...parsedSource, ...additionalMetadata };\n    }\n    await this.resolvePartials(parsedSource.template);\n    const renderString = this.handlebars.compile(\n      parsedSource.template,\n      {\n        knownHelpers: this.knownHelpers,\n        knownHelpersOnly: true,\n        noEscape: true\n      }\n    );\n    const renderFunc = async (data, options) => {\n      const { input, ...mergedMetadata } = await this.renderMetadata(parsedSource);\n      const renderedString = renderString(\n        { ...options?.input?.default || {}, ...data.input },\n        {\n          data: {\n            metadata: {\n              prompt: mergedMetadata,\n              docs: data.docs,\n              messages: data.messages\n            },\n            ...data.context || {}\n          }\n        }\n      );\n      return {\n        ...mergedMetadata,\n        messages: toMessages(renderedString, data)\n      };\n    };\n    renderFunc.prompt = parsedSource;\n    return renderFunc;\n  }\n  /**\n   * Processes and resolves all metadata for a prompt template.\n   *\n   * @param source The template source or parsed prompt\n   * @param additionalMetadata Additional metadata to include\n   * @return A promise resolving to the fully processed metadata\n   */\n  async renderMetadata(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    const selectedModel = additionalMetadata?.model || parsedSource.model || this.defaultModel;\n    let modelConfig;\n    if (selectedModel && this.modelConfigs[selectedModel]) {\n      modelConfig = this.modelConfigs[selectedModel];\n    }\n    return this.resolveMetadata(\n      modelConfig ? { config: modelConfig } : {},\n      parsedSource,\n      additionalMetadata\n    );\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kb3Rwcm9tcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsMkVBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixtQkFBTyxDQUFDLDJFQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLEVBQUUsK0JBQStCLHlCQUF5QixPQUFPO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VB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QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLFVBQVUsZ0NBQWdDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQixJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FJTCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRuLy4vbm9kZV9tb2R1bGVzL2RvdHByb21wdC9kaXN0L2luZGV4LmpzPzg1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbmRleF9leHBvcnRzLCB7XG4gIERvdHByb21wdDogKCkgPT4gRG90cHJvbXB0LFxuICBQaWNvc2NoZW1hUGFyc2VyOiAoKSA9PiBQaWNvc2NoZW1hUGFyc2VyLFxuICBwaWNvc2NoZW1hOiAoKSA9PiBwaWNvc2NoZW1hXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xuXG4vLyBzcmMvZG90cHJvbXB0LnRzXG52YXIgSGFuZGxlYmFycyA9IF9fdG9FU00ocmVxdWlyZShcImhhbmRsZWJhcnNcIikpO1xuXG4vLyBzcmMvaGVscGVycy50c1xudmFyIGhlbHBlcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaGVscGVyc19leHBvcnRzLCB7XG4gIGhpc3Rvcnk6ICgpID0+IGhpc3RvcnksXG4gIGlmRXF1YWxzOiAoKSA9PiBpZkVxdWFscyxcbiAganNvbjogKCkgPT4ganNvbixcbiAgbWVkaWE6ICgpID0+IG1lZGlhLFxuICByb2xlOiAoKSA9PiByb2xlLFxuICBzZWN0aW9uOiAoKSA9PiBzZWN0aW9uLFxuICB1bmxlc3NFcXVhbHM6ICgpID0+IHVubGVzc0VxdWFsc1xufSk7XG52YXIgaW1wb3J0X2hhbmRsZWJhcnMgPSByZXF1aXJlKFwiaGFuZGxlYmFyc1wiKTtcbmZ1bmN0aW9uIGpzb24oc2VyaWFsaXphYmxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgaW1wb3J0X2hhbmRsZWJhcnMuU2FmZVN0cmluZyhcbiAgICBKU09OLnN0cmluZ2lmeShzZXJpYWxpemFibGUsIG51bGwsIG9wdGlvbnMuaGFzaC5pbmRlbnQgfHwgMClcbiAgKTtcbn1cbmZ1bmN0aW9uIHJvbGUocm9sZTIpIHtcbiAgcmV0dXJuIG5ldyBpbXBvcnRfaGFuZGxlYmFycy5TYWZlU3RyaW5nKGA8PDxkb3Rwcm9tcHQ6cm9sZToke3JvbGUyfT4+PmApO1xufVxuZnVuY3Rpb24gaGlzdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBpbXBvcnRfaGFuZGxlYmFycy5TYWZlU3RyaW5nKFwiPDw8ZG90cHJvbXB0Omhpc3Rvcnk+Pj5cIik7XG59XG5mdW5jdGlvbiBzZWN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBpbXBvcnRfaGFuZGxlYmFycy5TYWZlU3RyaW5nKGA8PDxkb3Rwcm9tcHQ6c2VjdGlvbiAke25hbWV9Pj4+YCk7XG59XG5mdW5jdGlvbiBtZWRpYShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgaW1wb3J0X2hhbmRsZWJhcnMuU2FmZVN0cmluZyhcbiAgICBgPDw8ZG90cHJvbXB0Om1lZGlhOnVybCAke29wdGlvbnMuaGFzaC51cmx9JHtvcHRpb25zLmhhc2guY29udGVudFR5cGUgPyBgICR7b3B0aW9ucy5oYXNoLmNvbnRlbnRUeXBlfWAgOiBcIlwifT4+PmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGlmRXF1YWxzKGFyZzEsIGFyZzIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGFyZzEgPT09IGFyZzIgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xufVxuZnVuY3Rpb24gdW5sZXNzRXF1YWxzKGFyZzEsIGFyZzIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGFyZzEgIT09IGFyZzIgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xufVxuXG4vLyBzcmMvcGFyc2UudHNcbnZhciBpbXBvcnRfeWFtbCA9IHJlcXVpcmUoXCJ5YW1sXCIpO1xudmFyIFJPTEVfTUFSS0VSX1BSRUZJWCA9IFwiPDw8ZG90cHJvbXB0OnJvbGU6XCI7XG52YXIgSElTVE9SWV9NQVJLRVJfUFJFRklYID0gXCI8PDxkb3Rwcm9tcHQ6aGlzdG9yeVwiO1xudmFyIE1FRElBX01BUktFUl9QUkVGSVggPSBcIjw8PGRvdHByb21wdDptZWRpYTpcIjtcbnZhciBTRUNUSU9OX01BUktFUl9QUkVGSVggPSBcIjw8PGRvdHByb21wdDpzZWN0aW9uXCI7XG52YXIgRlJPTlRNQVRURVJfQU5EX0JPRFlfUkVHRVggPSAvXi0tLVxccypcXG4oW1xcc1xcU10qPylcXG4tLS1cXHMqXFxuKFtcXHNcXFNdKikkLztcbnZhciBST0xFX0FORF9ISVNUT1JZX01BUktFUl9SRUdFWCA9IC8oPDw8ZG90cHJvbXB0Oig/OnJvbGU6W2Etel0rfGhpc3RvcnkpKT4+Pi9nO1xudmFyIE1FRElBX0FORF9TRUNUSU9OX01BUktFUl9SRUdFWCA9IC8oPDw8ZG90cHJvbXB0Oig/Om1lZGlhOnVybHxzZWN0aW9uKS4qPyk+Pj4vZztcbnZhciBSRVNFUlZFRF9NRVRBREFUQV9LRVlXT1JEUyA9IFtcbiAgLy8gTk9URTogS0VFUCBTT1JURURcbiAgXCJjb25maWdcIixcbiAgXCJkZXNjcmlwdGlvblwiLFxuICBcImV4dFwiLFxuICBcImlucHV0XCIsXG4gIFwibW9kZWxcIixcbiAgXCJuYW1lXCIsXG4gIFwib3V0cHV0XCIsXG4gIFwicmF3XCIsXG4gIFwidG9vbERlZnNcIixcbiAgXCJ0b29sc1wiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ2ZXJzaW9uXCJcbl07XG52YXIgQkFTRV9NRVRBREFUQSA9IHtcbiAgZXh0OiB7fSxcbiAgbWV0YWRhdGE6IHt9LFxuICBjb25maWc6IHt9XG59O1xuZnVuY3Rpb24gc3BsaXRCeVJlZ2V4KHNvdXJjZSwgcmVnZXgpIHtcbiAgcmV0dXJuIHNvdXJjZS5zcGxpdChyZWdleCkuZmlsdGVyKChzKSA9PiBzLnRyaW0oKSAhPT0gXCJcIik7XG59XG5mdW5jdGlvbiBzcGxpdEJ5Um9sZUFuZEhpc3RvcnlNYXJrZXJzKHJlbmRlcmVkU3RyaW5nKSB7XG4gIHJldHVybiBzcGxpdEJ5UmVnZXgocmVuZGVyZWRTdHJpbmcsIFJPTEVfQU5EX0hJU1RPUllfTUFSS0VSX1JFR0VYKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlNZWRpYUFuZFNlY3Rpb25NYXJrZXJzKHNvdXJjZSkge1xuICByZXR1cm4gc3BsaXRCeVJlZ2V4KHNvdXJjZSwgTUVESUFfQU5EX1NFQ1RJT05fTUFSS0VSX1JFR0VYKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnROYW1lc3BhY2VkRW50cnlUb05lc3RlZE9iamVjdChrZXksIHZhbHVlLCBvYmogPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSBvYmogfHwge307XG4gIGNvbnN0IGxhc3REb3RJbmRleCA9IGtleS5sYXN0SW5kZXhPZihcIi5cIik7XG4gIGNvbnN0IG5zID0ga2V5LnN1YnN0cmluZygwLCBsYXN0RG90SW5kZXgpO1xuICBjb25zdCBmaWVsZCA9IGtleS5zdWJzdHJpbmcobGFzdERvdEluZGV4ICsgMSk7XG4gIHJlc3VsdFtuc10gPSByZXN1bHRbbnNdIHx8IHt9O1xuICByZXN1bHRbbnNdW2ZpZWxkXSA9IHZhbHVlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXh0cmFjdEZyb250bWF0dGVyQW5kQm9keShzb3VyY2UpIHtcbiAgY29uc3QgbWF0Y2ggPSBzb3VyY2UubWF0Y2goRlJPTlRNQVRURVJfQU5EX0JPRFlfUkVHRVgpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBjb25zdCBbLCBmcm9udG1hdHRlciwgYm9keV0gPSBtYXRjaDtcbiAgICByZXR1cm4geyBmcm9udG1hdHRlciwgYm9keSB9O1xuICB9XG4gIHJldHVybiB7IGZyb250bWF0dGVyOiBcIlwiLCBib2R5OiBcIlwiIH07XG59XG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHNvdXJjZSkge1xuICBjb25zdCB7IGZyb250bWF0dGVyLCBib2R5IH0gPSBleHRyYWN0RnJvbnRtYXR0ZXJBbmRCb2R5KHNvdXJjZSk7XG4gIGlmIChmcm9udG1hdHRlcikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRNZXRhZGF0YSA9ICgwLCBpbXBvcnRfeWFtbC5wYXJzZSkoZnJvbnRtYXR0ZXIpO1xuICAgICAgY29uc3QgcmF3ID0geyAuLi5wYXJzZWRNZXRhZGF0YSB9O1xuICAgICAgY29uc3QgcHJ1bmVkID0geyAuLi5CQVNFX01FVEFEQVRBIH07XG4gICAgICBjb25zdCBleHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgayBpbiByYXcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gaztcbiAgICAgICAgaWYgKFJFU0VSVkVEX01FVEFEQVRBX0tFWVdPUkRTLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBwcnVuZWRba2V5XSA9IHJhd1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgICBjb252ZXJ0TmFtZXNwYWNlZEVudHJ5VG9OZXN0ZWRPYmplY3Qoa2V5LCByYXdba2V5XSwgZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4ucHJ1bmVkLCByYXcsIGV4dCwgdGVtcGxhdGU6IGJvZHkudHJpbSgpIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJEb3Rwcm9tcHQ6IEVycm9yIHBhcnNpbmcgWUFNTCBmcm9udG1hdHRlcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgLi4uQkFTRV9NRVRBREFUQSwgdGVtcGxhdGU6IHNvdXJjZS50cmltKCkgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgLi4uQkFTRV9NRVRBREFUQSwgdGVtcGxhdGU6IHNvdXJjZSB9O1xufVxuZnVuY3Rpb24gbWVzc2FnZVNvdXJjZXNUb01lc3NhZ2VzKG1lc3NhZ2VTb3VyY2VzKSB7XG4gIHJldHVybiBtZXNzYWdlU291cmNlcy5maWx0ZXIoKG1zKSA9PiBtcy5jb250ZW50IHx8IG1zLnNvdXJjZSkubWFwKChtKSA9PiB7XG4gICAgY29uc3Qgb3V0ID0ge1xuICAgICAgcm9sZTogbS5yb2xlLFxuICAgICAgY29udGVudDogbS5jb250ZW50IHx8IHRvUGFydHMobS5zb3VyY2UgfHwgXCJcIilcbiAgICB9O1xuICAgIGlmIChtLm1ldGFkYXRhKSB7XG4gICAgICBvdXQubWV0YWRhdGEgPSBtLm1ldGFkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybU1lc3NhZ2VzVG9IaXN0b3J5KG1lc3NhZ2VzKSB7XG4gIHJldHVybiBtZXNzYWdlcy5tYXAoKG0pID0+ICh7XG4gICAgLi4ubSxcbiAgICBtZXRhZGF0YTogeyAuLi5tLm1ldGFkYXRhLCBwdXJwb3NlOiBcImhpc3RvcnlcIiB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHRvTWVzc2FnZXMocmVuZGVyZWRTdHJpbmcsIGRhdGEpIHtcbiAgbGV0IGN1cnJlbnRNZXNzYWdlID0geyByb2xlOiBcInVzZXJcIiwgc291cmNlOiBcIlwiIH07XG4gIGNvbnN0IG1lc3NhZ2VTb3VyY2VzID0gW2N1cnJlbnRNZXNzYWdlXTtcbiAgZm9yIChjb25zdCBwaWVjZSBvZiBzcGxpdEJ5Um9sZUFuZEhpc3RvcnlNYXJrZXJzKHJlbmRlcmVkU3RyaW5nKSkge1xuICAgIGlmIChwaWVjZS5zdGFydHNXaXRoKFJPTEVfTUFSS0VSX1BSRUZJWCkpIHtcbiAgICAgIGNvbnN0IHJvbGUyID0gcGllY2Uuc3Vic3RyaW5nKFJPTEVfTUFSS0VSX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlLnNvdXJjZT8udHJpbSgpKSB7XG4gICAgICAgIGN1cnJlbnRNZXNzYWdlID0geyByb2xlOiByb2xlMiwgc291cmNlOiBcIlwiIH07XG4gICAgICAgIG1lc3NhZ2VTb3VyY2VzLnB1c2goY3VycmVudE1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE1lc3NhZ2Uucm9sZSA9IHJvbGUyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGllY2Uuc3RhcnRzV2l0aChISVNUT1JZX01BUktFUl9QUkVGSVgpKSB7XG4gICAgICBjb25zdCBoaXN0b3J5TWVzc2FnZXMgPSB0cmFuc2Zvcm1NZXNzYWdlc1RvSGlzdG9yeShkYXRhPy5tZXNzYWdlcyA/PyBbXSk7XG4gICAgICBpZiAoaGlzdG9yeU1lc3NhZ2VzKSB7XG4gICAgICAgIG1lc3NhZ2VTb3VyY2VzLnB1c2goLi4uaGlzdG9yeU1lc3NhZ2VzKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRNZXNzYWdlID0geyByb2xlOiBcIm1vZGVsXCIsIHNvdXJjZTogXCJcIiB9O1xuICAgICAgbWVzc2FnZVNvdXJjZXMucHVzaChjdXJyZW50TWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRNZXNzYWdlLnNvdXJjZSArPSBwaWVjZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlU291cmNlc1RvTWVzc2FnZXMobWVzc2FnZVNvdXJjZXMpO1xuICByZXR1cm4gaW5zZXJ0SGlzdG9yeShtZXNzYWdlcywgZGF0YT8ubWVzc2FnZXMpO1xufVxuZnVuY3Rpb24gbWVzc2FnZXNIYXZlSGlzdG9yeShtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMuc29tZSgobSkgPT4gbS5tZXRhZGF0YT8ucHVycG9zZSA9PT0gXCJoaXN0b3J5XCIpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SGlzdG9yeShtZXNzYWdlcywgaGlzdG9yeTIgPSBbXSkge1xuICBpZiAoIWhpc3RvcnkyIHx8IG1lc3NhZ2VzSGF2ZUhpc3RvcnkobWVzc2FnZXMpKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9XG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGlzdG9yeTI7XG4gIH1cbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlcy5hdCgtMSk7XG4gIGlmIChsYXN0TWVzc2FnZT8ucm9sZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICBjb25zdCBtZXNzYWdlc1dpdGhvdXRMYXN0ID0gbWVzc2FnZXMuc2xpY2UoMCwgLTEpO1xuICAgIHJldHVybiBbLi4ubWVzc2FnZXNXaXRob3V0TGFzdCwgLi4uaGlzdG9yeTIsIGxhc3RNZXNzYWdlXTtcbiAgfVxuICByZXR1cm4gWy4uLm1lc3NhZ2VzLCAuLi5oaXN0b3J5Ml07XG59XG5mdW5jdGlvbiB0b1BhcnRzKHNvdXJjZSkge1xuICByZXR1cm4gc3BsaXRCeU1lZGlhQW5kU2VjdGlvbk1hcmtlcnMoc291cmNlKS5tYXAocGFyc2VQYXJ0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFydChwaWVjZSkge1xuICBpZiAocGllY2Uuc3RhcnRzV2l0aChNRURJQV9NQVJLRVJfUFJFRklYKSkge1xuICAgIHJldHVybiBwYXJzZU1lZGlhUGFydChwaWVjZSk7XG4gIH0gZWxzZSBpZiAocGllY2Uuc3RhcnRzV2l0aChTRUNUSU9OX01BUktFUl9QUkVGSVgpKSB7XG4gICAgcmV0dXJuIHBhcnNlU2VjdGlvblBhcnQocGllY2UpO1xuICB9XG4gIHJldHVybiBwYXJzZVRleHRQYXJ0KHBpZWNlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTWVkaWFQYXJ0KHBpZWNlKSB7XG4gIGlmICghcGllY2Uuc3RhcnRzV2l0aChNRURJQV9NQVJLRVJfUFJFRklYKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVkaWEgcGllY2VcIik7XG4gIH1cbiAgY29uc3QgW18sIHVybCwgY29udGVudFR5cGVdID0gcGllY2Uuc3BsaXQoXCIgXCIpO1xuICBjb25zdCBwYXJ0ID0geyBtZWRpYTogeyB1cmwgfSB9O1xuICBpZiAoY29udGVudFR5cGUpIHtcbiAgICBwYXJ0Lm1lZGlhLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gIH1cbiAgcmV0dXJuIHBhcnQ7XG59XG5mdW5jdGlvbiBwYXJzZVNlY3Rpb25QYXJ0KHBpZWNlKSB7XG4gIGlmICghcGllY2Uuc3RhcnRzV2l0aChTRUNUSU9OX01BUktFUl9QUkVGSVgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWN0aW9uIHBpZWNlXCIpO1xuICB9XG4gIGNvbnN0IFtfLCBzZWN0aW9uVHlwZV0gPSBwaWVjZS5zcGxpdChcIiBcIik7XG4gIHJldHVybiB7IG1ldGFkYXRhOiB7IHB1cnBvc2U6IHNlY3Rpb25UeXBlLCBwZW5kaW5nOiB0cnVlIH0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dFBhcnQocGllY2UpIHtcbiAgcmV0dXJuIHsgdGV4dDogcGllY2UgfTtcbn1cblxuLy8gc3JjL3BpY29zY2hlbWEudHNcbnZhciBKU09OX1NDSEVNQV9TQ0FMQVJfVFlQRVMgPSBbXG4gIFwic3RyaW5nXCIsXG4gIFwiYm9vbGVhblwiLFxuICBcIm51bGxcIixcbiAgXCJudW1iZXJcIixcbiAgXCJpbnRlZ2VyXCIsXG4gIFwiYW55XCJcbl07XG52YXIgV0lMRENBUkRfUFJPUEVSVFlfTkFNRSA9IFwiKCopXCI7XG5hc3luYyBmdW5jdGlvbiBwaWNvc2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBpY29zY2hlbWFQYXJzZXIob3B0aW9ucykucGFyc2Uoc2NoZW1hKTtcbn1cbnZhciBQaWNvc2NoZW1hUGFyc2VyID0gY2xhc3Mge1xuICBzY2hlbWFSZXNvbHZlcjtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc2NoZW1hUmVzb2x2ZXIgPSBvcHRpb25zPy5zY2hlbWFSZXNvbHZlcjtcbiAgfVxuICBhc3luYyBtdXN0UmVzb2x2ZVNjaGVtYShzY2hlbWFOYW1lKSB7XG4gICAgaWYgKCF0aGlzLnNjaGVtYVJlc29sdmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBpY29zY2hlbWE6IHVuc3VwcG9ydGVkIHNjYWxhciB0eXBlICcke3NjaGVtYU5hbWV9Jy5gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gYXdhaXQgdGhpcy5zY2hlbWFSZXNvbHZlcihzY2hlbWFOYW1lKTtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGljb3NjaGVtYTogY291bGQgbm90IGZpbmQgc2NoZW1hIHdpdGggbmFtZSAnJHtzY2hlbWFOYW1lfSdgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGFzeW5jIHBhcnNlKHNjaGVtYSkge1xuICAgIGlmICghc2NoZW1hKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgW3R5cGUsIGRlc2NyaXB0aW9uXSA9IGV4dHJhY3REZXNjcmlwdGlvbihzY2hlbWEpO1xuICAgICAgaWYgKEpTT05fU0NIRU1BX1NDQUxBUl9UWVBFUy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBsZXQgb3V0ID0geyB0eXBlIH07XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikgb3V0ID0geyAuLi5vdXQsIGRlc2NyaXB0aW9uIH07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IGF3YWl0IHRoaXMubXVzdFJlc29sdmVTY2hlbWEodHlwZSk7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb24gPyB7IC4uLnJlc29sdmVkU2NoZW1hLCBkZXNjcmlwdGlvbiB9IDogcmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGlmIChbLi4uSlNPTl9TQ0hFTUFfU0NBTEFSX1RZUEVTLCBcIm9iamVjdFwiLCBcImFycmF5XCJdLmluY2x1ZGVzKFxuICAgICAgc2NoZW1hPy50eXBlXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2hlbWE/LnByb3BlcnRpZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiB7IC4uLnNjaGVtYSwgdHlwZTogXCJvYmplY3RcIiB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVBpY28oc2NoZW1hKTtcbiAgfVxuICBhc3luYyBwYXJzZVBpY28ob2JqLCBwYXRoID0gW10pIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgW3R5cGUsIGRlc2NyaXB0aW9uXSA9IGV4dHJhY3REZXNjcmlwdGlvbihvYmopO1xuICAgICAgaWYgKCFKU09OX1NDSEVNQV9TQ0FMQVJfVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkU2NoZW1hID0gYXdhaXQgdGhpcy5tdXN0UmVzb2x2ZVNjaGVtYSh0eXBlKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSByZXNvbHZlZFNjaGVtYSA9IHsgLi4ucmVzb2x2ZWRTY2hlbWEsIGRlc2NyaXB0aW9uIH07XG4gICAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImFueVwiKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbiA/IHsgZGVzY3JpcHRpb24gfSA6IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uID8geyB0eXBlLCBkZXNjcmlwdGlvbiB9IDogeyB0eXBlIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUGljb3NjaGVtYTogb25seSBjb25zaXN0cyBvZiBvYmplY3RzIGFuZCBzdHJpbmdzLiBHb3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgcmVxdWlyZWQ6IFtdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChrZXkgPT09IFdJTERDQVJEX1BST1BFUlRZX05BTUUpIHtcbiAgICAgICAgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gYXdhaXQgdGhpcy5wYXJzZVBpY28ob2JqW2tleV0sIFtcbiAgICAgICAgICAuLi5wYXRoLFxuICAgICAgICAgIGtleVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbbmFtZSwgdHlwZUluZm9dID0ga2V5LnNwbGl0KFwiKFwiKTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBuYW1lLmVuZHNXaXRoKFwiP1wiKTtcbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGlzT3B0aW9uYWwgPyBuYW1lLnNsaWNlKDAsIC0xKSA6IG5hbWU7XG4gICAgICBpZiAoIWlzT3B0aW9uYWwpIHtcbiAgICAgICAgc2NoZW1hLnJlcXVpcmVkLnB1c2gocHJvcGVydHlOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZUluZm8pIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHsgLi4uYXdhaXQgdGhpcy5wYXJzZVBpY28ob2JqW2tleV0sIFsuLi5wYXRoLCBrZXldKSB9O1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB0eXBlb2YgcHJvcC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcHJvcC50eXBlID0gW3Byb3AudHlwZSwgXCJudWxsXCJdO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt0eXBlLCBkZXNjcmlwdGlvbl0gPSBleHRyYWN0RGVzY3JpcHRpb24oXG4gICAgICAgIHR5cGVJbmZvLnN1YnN0cmluZygwLCB0eXBlSW5mby5sZW5ndGggLSAxKVxuICAgICAgKTtcbiAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBpc09wdGlvbmFsID8gW1wiYXJyYXlcIiwgXCJudWxsXCJdIDogXCJhcnJheVwiLFxuICAgICAgICAgIGl0ZW1zOiBhd2FpdCB0aGlzLnBhcnNlUGljbyhvYmpba2V5XSwgWy4uLnBhdGgsIGtleV0pXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGF3YWl0IHRoaXMucGFyc2VQaWNvKG9ialtrZXldLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgIGlmIChpc09wdGlvbmFsKSBwcm9wLnR5cGUgPSBbcHJvcC50eXBlLCBcIm51bGxcIl07XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBwcm9wID0geyBlbnVtOiBvYmpba2V5XSB9O1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiAhcHJvcC5lbnVtLmluY2x1ZGVzKG51bGwpKSBwcm9wLmVudW0ucHVzaChudWxsKTtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHByb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJQaWNvc2NoZW1hOiBwYXJlbnRoZXRpY2FsIHR5cGVzIG11c3QgYmUgJ29iamVjdCcgb3IgJ2FycmF5JywgZ290OiBcIiArIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCkgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdERlc2NyaXB0aW9uKGlucHV0KSB7XG4gIGlmICghaW5wdXQuaW5jbHVkZXMoXCIsXCIpKSByZXR1cm4gW2lucHV0LCBudWxsXTtcbiAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvKC4qPyksICooLiopJC8pO1xuICByZXR1cm4gW21hdGNoWzFdLCBtYXRjaFsyXV07XG59XG5cbi8vIHNyYy91dGlsLnRzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRGaWVsZHMob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKChpdGVtKSA9PiByZW1vdmVVbmRlZmluZWRGaWVsZHMoaXRlbSkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcmVtb3ZlVW5kZWZpbmVkRmllbGRzKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2RvdHByb21wdC50c1xudmFyIERvdHByb21wdCA9IGNsYXNzIHtcbiAgaGFuZGxlYmFycztcbiAga25vd25IZWxwZXJzID0ge307XG4gIGRlZmF1bHRNb2RlbDtcbiAgbW9kZWxDb25maWdzID0ge307XG4gIHRvb2xzID0ge307XG4gIHRvb2xSZXNvbHZlcjtcbiAgc2NoZW1hcyA9IHt9O1xuICBzY2hlbWFSZXNvbHZlcjtcbiAgcGFydGlhbFJlc29sdmVyO1xuICBzdG9yZTtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlYmFycyA9IEhhbmRsZWJhcnMubm9Db25mbGljdCgpO1xuICAgIHRoaXMubW9kZWxDb25maWdzID0gb3B0aW9ucz8ubW9kZWxDb25maWdzIHx8IHRoaXMubW9kZWxDb25maWdzO1xuICAgIHRoaXMuZGVmYXVsdE1vZGVsID0gb3B0aW9ucz8uZGVmYXVsdE1vZGVsO1xuICAgIHRoaXMudG9vbHMgPSBvcHRpb25zPy50b29scyB8fCB7fTtcbiAgICB0aGlzLnRvb2xSZXNvbHZlciA9IG9wdGlvbnM/LnRvb2xSZXNvbHZlcjtcbiAgICB0aGlzLnNjaGVtYXMgPSBvcHRpb25zPy5zY2hlbWFzIHx8IHt9O1xuICAgIHRoaXMuc2NoZW1hUmVzb2x2ZXIgPSBvcHRpb25zPy5zY2hlbWFSZXNvbHZlcjtcbiAgICB0aGlzLnBhcnRpYWxSZXNvbHZlciA9IG9wdGlvbnM/LnBhcnRpYWxSZXNvbHZlcjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWxwZXJzX2V4cG9ydHMpIHtcbiAgICAgIHRoaXMuZGVmaW5lSGVscGVyKGtleSwgaGVscGVyc19leHBvcnRzW2tleV0pO1xuICAgICAgdGhpcy5oYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKGtleSwgaGVscGVyc19leHBvcnRzW2tleV0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uaGVscGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5oZWxwZXJzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lSGVscGVyKGtleSwgb3B0aW9ucy5oZWxwZXJzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ucGFydGlhbHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucGFydGlhbHMpIHtcbiAgICAgICAgdGhpcy5kZWZpbmVQYXJ0aWFsKGtleSwgb3B0aW9ucy5wYXJ0aWFsc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgdXNlIGluIHRlbXBsYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlclxuICAgKiBAcGFyYW0gZm4gVGhlIGhlbHBlciBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKiBAcmV0dXJuIFRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cbiAgZGVmaW5lSGVscGVyKG5hbWUsIGZuKSB7XG4gICAgdGhpcy5oYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKG5hbWUsIGZuKTtcbiAgICB0aGlzLmtub3duSGVscGVyc1tuYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHBhcnRpYWwgdGVtcGxhdGUgZm9yIHVzZSBpbiBvdGhlciB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsIHRvIHJlZ2lzdGVyXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBmb3IgdGhlIHBhcnRpYWxcbiAgICogQHJldHVybiBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG4gIGRlZmluZVBhcnRpYWwobmFtZSwgc291cmNlKSB7XG4gICAgdGhpcy5oYW5kbGViYXJzLnJlZ2lzdGVyUGFydGlhbChuYW1lLCBzb3VyY2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSB0b29sIGRlZmluaXRpb24gZm9yIHVzZSBpbiBwcm9tcHRzLlxuICAgKlxuICAgKiBAcGFyYW0gZGVmIFRoZSB0b29sIGRlZmluaXRpb24gdG8gcmVnaXN0ZXJcbiAgICogQHJldHVybiBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG4gIGRlZmluZVRvb2woZGVmKSB7XG4gICAgdGhpcy50b29sc1tkZWYubmFtZV0gPSBkZWY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHByb21wdCB0ZW1wbGF0ZSBzdHJpbmcgaW50byBhIHN0cnVjdHVyZWQgUGFyc2VkUHJvbXB0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZSBUaGUgdGVtcGxhdGUgc291cmNlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIEEgcGFyc2VkIHByb21wdCBvYmplY3Qgd2l0aCBleHRyYWN0ZWQgbWV0YWRhdGEgYW5kIHRlbXBsYXRlXG4gICAqL1xuICBwYXJzZShzb3VyY2UpIHtcbiAgICByZXR1cm4gcGFyc2VEb2N1bWVudChzb3VyY2UpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgcHJvbXB0IHRlbXBsYXRlIHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBzdHJpbmcgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgdGVtcGxhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBtZXRhZGF0YSBhbmQgb3B0aW9ucyBmb3IgcmVuZGVyaW5nXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVuZGVyZWQgcHJvbXB0XG4gICAqL1xuICBhc3luYyByZW5kZXIoc291cmNlLCBkYXRhID0ge30sIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IGF3YWl0IHRoaXMuY29tcGlsZShzb3VyY2UpO1xuICAgIHJldHVybiByZW5kZXJlcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIHNjaGVtYSBkZWZpbml0aW9ucyBpbiBwaWNvc2NoZW1hIGZvcm1hdCBpbnRvIHN0YW5kYXJkIEpTT04gU2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0YSBUaGUgcHJvbXB0IG1ldGFkYXRhIGNvbnRhaW5pbmcgc2NoZW1hIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJvY2Vzc2VkIG1ldGFkYXRhIHdpdGggZXhwYW5kZWQgc2NoZW1hc1xuICAgKi9cbiAgYXN5bmMgcmVuZGVyUGljb3NjaGVtYShtZXRhKSB7XG4gICAgaWYgKCFtZXRhLm91dHB1dD8uc2NoZW1hICYmICFtZXRhLmlucHV0Py5zY2hlbWEpIHtcbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBjb25zdCBuZXdNZXRhID0geyAuLi5tZXRhIH07XG4gICAgaWYgKG1ldGEuaW5wdXQ/LnNjaGVtYSkge1xuICAgICAgbmV3TWV0YS5pbnB1dCA9IHtcbiAgICAgICAgLi4ubWV0YS5pbnB1dCxcbiAgICAgICAgc2NoZW1hOiBhd2FpdCBwaWNvc2NoZW1hKG1ldGEuaW5wdXQuc2NoZW1hLCB7XG4gICAgICAgICAgc2NoZW1hUmVzb2x2ZXI6IHRoaXMud3JhcHBlZFNjaGVtYVJlc29sdmVyLmJpbmQodGhpcylcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtZXRhLm91dHB1dD8uc2NoZW1hKSB7XG4gICAgICBuZXdNZXRhLm91dHB1dCA9IHtcbiAgICAgICAgLi4ubWV0YS5vdXRwdXQsXG4gICAgICAgIHNjaGVtYTogYXdhaXQgcGljb3NjaGVtYShtZXRhLm91dHB1dC5zY2hlbWEsIHtcbiAgICAgICAgICBzY2hlbWFSZXNvbHZlcjogdGhpcy53cmFwcGVkU2NoZW1hUmVzb2x2ZXIuYmluZCh0aGlzKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01ldGE7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGEgc2NoZW1hIG5hbWUgdG8gaXRzIGRlZmluaXRpb24sIHVzaW5nIHJlZ2lzdGVyZWQgc2NoZW1hcyBvciBzY2hlbWEgcmVzb2x2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHNjaGVtYSBkZWZpbml0aW9uIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAqL1xuICBhc3luYyB3cmFwcGVkU2NoZW1hUmVzb2x2ZXIobmFtZSkge1xuICAgIGlmICh0aGlzLnNjaGVtYXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVtYXNbbmFtZV07XG4gICAgfVxuICAgIGlmICh0aGlzLnNjaGVtYVJlc29sdmVyKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zY2hlbWFSZXNvbHZlcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlcyBtdWx0aXBsZSBtZXRhZGF0YSBvYmplY3RzIHRvZ2V0aGVyLCByZXNvbHZpbmcgdG9vbHMgYW5kIHNjaGVtYXMuXG4gICAqXG4gICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIG1ldGFkYXRhIG9iamVjdFxuICAgKiBAcGFyYW0gbWVyZ2VzIEFkZGl0aW9uYWwgbWV0YWRhdGEgb2JqZWN0cyB0byBtZXJnZSBpbnRvIHRoZSBiYXNlXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVyZ2VkIGFuZCBwcm9jZXNzZWQgbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHJlc29sdmVNZXRhZGF0YShiYXNlLCAuLi5tZXJnZXMpIHtcbiAgICBsZXQgb3V0ID0geyAuLi5iYXNlIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXJnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbWVyZ2VzW2ldKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG91dC5jb25maWcgfHwge307XG4gICAgICBvdXQgPSB7IC4uLm91dCwgLi4ubWVyZ2VzW2ldIH07XG4gICAgICBvdXQuY29uZmlnID0geyAuLi5jb25maWcsIC4uLm1lcmdlc1tpXT8uY29uZmlnIHx8IHt9IH07XG4gICAgfVxuICAgIGNvbnN0IHsgdGVtcGxhdGU6IF8sIC4uLm91dFdpdGhvdXRUZW1wbGF0ZSB9ID0gb3V0O1xuICAgIG91dCA9IG91dFdpdGhvdXRUZW1wbGF0ZTtcbiAgICBvdXQgPSByZW1vdmVVbmRlZmluZWRGaWVsZHMob3V0KTtcbiAgICBvdXQgPSBhd2FpdCB0aGlzLnJlc29sdmVUb29scyhvdXQpO1xuICAgIG91dCA9IGF3YWl0IHRoaXMucmVuZGVyUGljb3NjaGVtYShvdXQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRvb2wgbmFtZXMgdG8gdGhlaXIgZGVmaW5pdGlvbnMgdXNpbmcgcmVnaXN0ZXJlZCB0b29scyBvciB0b29sIHJlc29sdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZSBUaGUgbWV0YWRhdGEgY29udGFpbmluZyB0b29sIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZVxuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbWV0YWRhdGEgd2l0aCByZXNvbHZlZCB0b29sIGRlZmluaXRpb25zXG4gICAqL1xuICBhc3luYyByZXNvbHZlVG9vbHMoYmFzZSkge1xuICAgIGNvbnN0IG91dCA9IHsgLi4uYmFzZSB9O1xuICAgIGlmIChvdXQudG9vbHMpIHtcbiAgICAgIGNvbnN0IG91dFRvb2xzID0gW107XG4gICAgICBvdXQudG9vbERlZnMgPSBvdXQudG9vbERlZnMgfHwgW107XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgb3V0LnRvb2xzLm1hcChhc3luYyAodG9vbE5hbWUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy50b29sc1t0b29sTmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChvdXQudG9vbERlZnMpIHtcbiAgICAgICAgICAgICAgb3V0LnRvb2xEZWZzLnB1c2godGhpcy50b29sc1t0b29sTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b29sUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkVG9vbCA9IGF3YWl0IHRoaXMudG9vbFJlc29sdmVyKHRvb2xOYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWRUb29sKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRG90cHJvbXB0OiBVbmFibGUgdG8gcmVzb2x2ZSB0b29sICcke3Rvb2xOYW1lfScgdG8gYSByZWNvZ25pemVkIHRvb2wgZGVmaW5pdGlvbi5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0LnRvb2xEZWZzKSB7XG4gICAgICAgICAgICAgIG91dC50b29sRGVmcy5wdXNoKHJlc29sdmVkVG9vbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dFRvb2xzLnB1c2godG9vbE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBvdXQudG9vbHMgPSBvdXRUb29scztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogSWRlbnRpZmllcyBhbGwgcGFydGlhbCByZWZlcmVuY2VzIGluIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgdG8gc2NhbiBmb3IgcGFydGlhbCByZWZlcmVuY2VzXG4gICAqIEByZXR1cm4gQSBzZXQgb2YgcGFydGlhbCBuYW1lcyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZVxuICAgKi9cbiAgaWRlbnRpZnlQYXJ0aWFscyh0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IGFzdCA9IHRoaXMuaGFuZGxlYmFycy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgcGFydGlhbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgY2xhc3MgZXh0ZW5kcyB0aGlzLmhhbmRsZWJhcnMuVmlzaXRvciB7XG4gICAgICAvLyBWaXNpdCBwYXJ0aWFsIHN0YXRlbWVudHMgYW5kIGFkZCB0aGVpciBuYW1lcyB0byBvdXIgc2V0LlxuICAgICAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsICYmIHR5cGVvZiBwYXJ0aWFsID09PSBcIm9iamVjdFwiICYmIFwibmFtZVwiIGluIHBhcnRpYWwgJiYgcGFydGlhbC5uYW1lICYmIHR5cGVvZiBwYXJ0aWFsLm5hbWUgPT09IFwib2JqZWN0XCIgJiYgXCJvcmlnaW5hbFwiIGluIHBhcnRpYWwubmFtZSAmJiB0eXBlb2YgcGFydGlhbC5uYW1lLm9yaWdpbmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFydGlhbHMuYWRkKHBhcnRpYWwubmFtZS5vcmlnaW5hbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdmlzaXRvci5hY2NlcHQoYXN0KTtcbiAgICByZXR1cm4gcGFydGlhbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuZCByZWdpc3RlcnMgYWxsIHBhcnRpYWxzIHJlZmVyZW5jZWQgaW4gYSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBjb250YWluaW5nIHBhcnRpYWwgcmVmZXJlbmNlc1xuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHBhcnRpYWxzIGFyZSByZWdpc3RlcmVkXG4gICAqL1xuICBhc3luYyByZXNvbHZlUGFydGlhbHModGVtcGxhdGUpIHtcbiAgICBpZiAoIXRoaXMucGFydGlhbFJlc29sdmVyICYmICF0aGlzLnN0b3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpYWxzID0gdGhpcy5pZGVudGlmeVBhcnRpYWxzKHRlbXBsYXRlKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20ocGFydGlhbHMpLm1hcChhc3luYyAobmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlYmFycy5wYXJ0aWFsc1tuYW1lXSkge1xuICAgICAgICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICBpZiAodGhpcy5wYXJ0aWFsUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBhcnRpYWxSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250ZW50ICYmIHRoaXMuc3RvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpYWwgPSBhd2FpdCB0aGlzLnN0b3JlLmxvYWRQYXJ0aWFsKG5hbWUpO1xuICAgICAgICAgICAgY29udGVudCA9IHBhcnRpYWw/LnNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lUGFydGlhbChuYW1lLCBjb250ZW50KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzb2x2ZVBhcnRpYWxzKGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlcyBhIHRlbXBsYXRlIGludG8gYSByZXVzYWJsZSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHByb21wdHMuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBvciBwYXJzZWQgcHJvbXB0IHRvIGNvbXBpbGVcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxNZXRhZGF0YSBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgdGhlIHRlbXBsYXRlXG4gICAqL1xuICBhc3luYyBjb21waWxlKHNvdXJjZSwgYWRkaXRpb25hbE1ldGFkYXRhKSB7XG4gICAgbGV0IHBhcnNlZFNvdXJjZTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyc2VkU291cmNlID0gdGhpcy5wYXJzZShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRTb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChhZGRpdGlvbmFsTWV0YWRhdGEpIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHsgLi4ucGFyc2VkU291cmNlLCAuLi5hZGRpdGlvbmFsTWV0YWRhdGEgfTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXNvbHZlUGFydGlhbHMocGFyc2VkU291cmNlLnRlbXBsYXRlKTtcbiAgICBjb25zdCByZW5kZXJTdHJpbmcgPSB0aGlzLmhhbmRsZWJhcnMuY29tcGlsZShcbiAgICAgIHBhcnNlZFNvdXJjZS50ZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAga25vd25IZWxwZXJzOiB0aGlzLmtub3duSGVscGVycyxcbiAgICAgICAga25vd25IZWxwZXJzT25seTogdHJ1ZSxcbiAgICAgICAgbm9Fc2NhcGU6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlbmRlckZ1bmMgPSBhc3luYyAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dCwgLi4ubWVyZ2VkTWV0YWRhdGEgfSA9IGF3YWl0IHRoaXMucmVuZGVyTWV0YWRhdGEocGFyc2VkU291cmNlKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkU3RyaW5nID0gcmVuZGVyU3RyaW5nKFxuICAgICAgICB7IC4uLm9wdGlvbnM/LmlucHV0Py5kZWZhdWx0IHx8IHt9LCAuLi5kYXRhLmlucHV0IH0sXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBwcm9tcHQ6IG1lcmdlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICBkb2NzOiBkYXRhLmRvY3MsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBkYXRhLm1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uZGF0YS5jb250ZXh0IHx8IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VkTWV0YWRhdGEsXG4gICAgICAgIG1lc3NhZ2VzOiB0b01lc3NhZ2VzKHJlbmRlcmVkU3RyaW5nLCBkYXRhKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJlbmRlckZ1bmMucHJvbXB0ID0gcGFyc2VkU291cmNlO1xuICAgIHJldHVybiByZW5kZXJGdW5jO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW5kIHJlc29sdmVzIGFsbCBtZXRhZGF0YSBmb3IgYSBwcm9tcHQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBvciBwYXJzZWQgcHJvbXB0XG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsTWV0YWRhdGEgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBpbmNsdWRlXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgZnVsbHkgcHJvY2Vzc2VkIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyByZW5kZXJNZXRhZGF0YShzb3VyY2UsIGFkZGl0aW9uYWxNZXRhZGF0YSkge1xuICAgIGxldCBwYXJzZWRTb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHRoaXMucGFyc2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE1vZGVsID0gYWRkaXRpb25hbE1ldGFkYXRhPy5tb2RlbCB8fCBwYXJzZWRTb3VyY2UubW9kZWwgfHwgdGhpcy5kZWZhdWx0TW9kZWw7XG4gICAgbGV0IG1vZGVsQ29uZmlnO1xuICAgIGlmIChzZWxlY3RlZE1vZGVsICYmIHRoaXMubW9kZWxDb25maWdzW3NlbGVjdGVkTW9kZWxdKSB7XG4gICAgICBtb2RlbENvbmZpZyA9IHRoaXMubW9kZWxDb25maWdzW3NlbGVjdGVkTW9kZWxdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlTWV0YWRhdGEoXG4gICAgICBtb2RlbENvbmZpZyA/IHsgY29uZmlnOiBtb2RlbENvbmZpZyB9IDoge30sXG4gICAgICBwYXJzZWRTb3VyY2UsXG4gICAgICBhZGRpdGlvbmFsTWV0YWRhdGFcbiAgICApO1xuICB9XG59O1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIERvdHByb21wdCxcbiAgUGljb3NjaGVtYVBhcnNlcixcbiAgcGljb3NjaGVtYVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/dotprompt/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dotprompt/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dotprompt/dist/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  Dotprompt: () => Dotprompt,\n  PicoschemaParser: () => PicoschemaParser,\n  picoschema: () => picoschema\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/dotprompt.ts\nvar Handlebars = __toESM(__webpack_require__(/*! handlebars */ \"(rsc)/./node_modules/handlebars/lib/index.js\"));\n\n// src/helpers.ts\nvar helpers_exports = {};\n__export(helpers_exports, {\n  history: () => history,\n  ifEquals: () => ifEquals,\n  json: () => json,\n  media: () => media,\n  role: () => role,\n  section: () => section,\n  unlessEquals: () => unlessEquals\n});\nvar import_handlebars = __webpack_require__(/*! handlebars */ \"(rsc)/./node_modules/handlebars/lib/index.js\");\nfunction json(serializable, options) {\n  return new import_handlebars.SafeString(\n    JSON.stringify(serializable, null, options.hash.indent || 0)\n  );\n}\nfunction role(role2) {\n  return new import_handlebars.SafeString(`<<<dotprompt:role:${role2}>>>`);\n}\nfunction history() {\n  return new import_handlebars.SafeString(\"<<<dotprompt:history>>>\");\n}\nfunction section(name) {\n  return new import_handlebars.SafeString(`<<<dotprompt:section ${name}>>>`);\n}\nfunction media(options) {\n  return new import_handlebars.SafeString(\n    `<<<dotprompt:media:url ${options.hash.url}${options.hash.contentType ? ` ${options.hash.contentType}` : \"\"}>>>`\n  );\n}\nfunction ifEquals(arg1, arg2, options) {\n  return arg1 === arg2 ? options.fn(this) : options.inverse(this);\n}\nfunction unlessEquals(arg1, arg2, options) {\n  return arg1 !== arg2 ? options.fn(this) : options.inverse(this);\n}\n\n// src/parse.ts\nvar import_yaml = __webpack_require__(/*! yaml */ \"(rsc)/./node_modules/yaml/dist/index.js\");\nvar ROLE_MARKER_PREFIX = \"<<<dotprompt:role:\";\nvar HISTORY_MARKER_PREFIX = \"<<<dotprompt:history\";\nvar MEDIA_MARKER_PREFIX = \"<<<dotprompt:media:\";\nvar SECTION_MARKER_PREFIX = \"<<<dotprompt:section\";\nvar FRONTMATTER_AND_BODY_REGEX = /^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/;\nvar ROLE_AND_HISTORY_MARKER_REGEX = /(<<<dotprompt:(?:role:[a-z]+|history))>>>/g;\nvar MEDIA_AND_SECTION_MARKER_REGEX = /(<<<dotprompt:(?:media:url|section).*?)>>>/g;\nvar RESERVED_METADATA_KEYWORDS = [\n  // NOTE: KEEP SORTED\n  \"config\",\n  \"description\",\n  \"ext\",\n  \"input\",\n  \"model\",\n  \"name\",\n  \"output\",\n  \"raw\",\n  \"toolDefs\",\n  \"tools\",\n  \"variant\",\n  \"version\"\n];\nvar BASE_METADATA = {\n  ext: {},\n  metadata: {},\n  config: {}\n};\nfunction splitByRegex(source, regex) {\n  return source.split(regex).filter((s) => s.trim() !== \"\");\n}\nfunction splitByRoleAndHistoryMarkers(renderedString) {\n  return splitByRegex(renderedString, ROLE_AND_HISTORY_MARKER_REGEX);\n}\nfunction splitByMediaAndSectionMarkers(source) {\n  return splitByRegex(source, MEDIA_AND_SECTION_MARKER_REGEX);\n}\nfunction convertNamespacedEntryToNestedObject(key, value, obj = {}) {\n  const result = obj || {};\n  const lastDotIndex = key.lastIndexOf(\".\");\n  const ns = key.substring(0, lastDotIndex);\n  const field = key.substring(lastDotIndex + 1);\n  result[ns] = result[ns] || {};\n  result[ns][field] = value;\n  return result;\n}\nfunction extractFrontmatterAndBody(source) {\n  const match = source.match(FRONTMATTER_AND_BODY_REGEX);\n  if (match) {\n    const [, frontmatter, body] = match;\n    return { frontmatter, body };\n  }\n  return { frontmatter: \"\", body: \"\" };\n}\nfunction parseDocument(source) {\n  const { frontmatter, body } = extractFrontmatterAndBody(source);\n  if (frontmatter) {\n    try {\n      const parsedMetadata = (0, import_yaml.parse)(frontmatter);\n      const raw = { ...parsedMetadata };\n      const pruned = { ...BASE_METADATA };\n      const ext = {};\n      for (const k in raw) {\n        const key = k;\n        if (RESERVED_METADATA_KEYWORDS.includes(key)) {\n          pruned[key] = raw[key];\n        } else if (key.includes(\".\")) {\n          convertNamespacedEntryToNestedObject(key, raw[key], ext);\n        }\n      }\n      return { ...pruned, raw, ext, template: body.trim() };\n    } catch (error) {\n      console.error(\"Dotprompt: Error parsing YAML frontmatter:\", error);\n      return { ...BASE_METADATA, template: source.trim() };\n    }\n  }\n  return { ...BASE_METADATA, template: source };\n}\nfunction messageSourcesToMessages(messageSources) {\n  return messageSources.filter((ms) => ms.content || ms.source).map((m) => {\n    const out = {\n      role: m.role,\n      content: m.content || toParts(m.source || \"\")\n    };\n    if (m.metadata) {\n      out.metadata = m.metadata;\n    }\n    return out;\n  });\n}\nfunction transformMessagesToHistory(messages) {\n  return messages.map((m) => ({\n    ...m,\n    metadata: { ...m.metadata, purpose: \"history\" }\n  }));\n}\nfunction toMessages(renderedString, data) {\n  let currentMessage = { role: \"user\", source: \"\" };\n  const messageSources = [currentMessage];\n  for (const piece of splitByRoleAndHistoryMarkers(renderedString)) {\n    if (piece.startsWith(ROLE_MARKER_PREFIX)) {\n      const role2 = piece.substring(ROLE_MARKER_PREFIX.length);\n      if (currentMessage.source?.trim()) {\n        currentMessage = { role: role2, source: \"\" };\n        messageSources.push(currentMessage);\n      } else {\n        currentMessage.role = role2;\n      }\n    } else if (piece.startsWith(HISTORY_MARKER_PREFIX)) {\n      const historyMessages = transformMessagesToHistory(data?.messages ?? []);\n      if (historyMessages) {\n        messageSources.push(...historyMessages);\n      }\n      currentMessage = { role: \"model\", source: \"\" };\n      messageSources.push(currentMessage);\n    } else {\n      currentMessage.source += piece;\n    }\n  }\n  const messages = messageSourcesToMessages(messageSources);\n  return insertHistory(messages, data?.messages);\n}\nfunction messagesHaveHistory(messages) {\n  return messages.some((m) => m.metadata?.purpose === \"history\");\n}\nfunction insertHistory(messages, history2 = []) {\n  if (!history2 || messagesHaveHistory(messages)) {\n    return messages;\n  }\n  if (messages.length === 0) {\n    return history2;\n  }\n  const lastMessage = messages.at(-1);\n  if (lastMessage?.role === \"user\") {\n    const messagesWithoutLast = messages.slice(0, -1);\n    return [...messagesWithoutLast, ...history2, lastMessage];\n  }\n  return [...messages, ...history2];\n}\nfunction toParts(source) {\n  return splitByMediaAndSectionMarkers(source).map(parsePart);\n}\nfunction parsePart(piece) {\n  if (piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    return parseMediaPart(piece);\n  } else if (piece.startsWith(SECTION_MARKER_PREFIX)) {\n    return parseSectionPart(piece);\n  }\n  return parseTextPart(piece);\n}\nfunction parseMediaPart(piece) {\n  if (!piece.startsWith(MEDIA_MARKER_PREFIX)) {\n    throw new Error(\"Invalid media piece\");\n  }\n  const [_, url, contentType] = piece.split(\" \");\n  const part = { media: { url } };\n  if (contentType) {\n    part.media.contentType = contentType;\n  }\n  return part;\n}\nfunction parseSectionPart(piece) {\n  if (!piece.startsWith(SECTION_MARKER_PREFIX)) {\n    throw new Error(\"Invalid section piece\");\n  }\n  const [_, sectionType] = piece.split(\" \");\n  return { metadata: { purpose: sectionType, pending: true } };\n}\nfunction parseTextPart(piece) {\n  return { text: piece };\n}\n\n// src/picoschema.ts\nvar JSON_SCHEMA_SCALAR_TYPES = [\n  \"string\",\n  \"boolean\",\n  \"null\",\n  \"number\",\n  \"integer\",\n  \"any\"\n];\nvar WILDCARD_PROPERTY_NAME = \"(*)\";\nasync function picoschema(schema, options) {\n  return new PicoschemaParser(options).parse(schema);\n}\nvar PicoschemaParser = class {\n  schemaResolver;\n  constructor(options) {\n    this.schemaResolver = options?.schemaResolver;\n  }\n  async mustResolveSchema(schemaName) {\n    if (!this.schemaResolver) {\n      throw new Error(`Picoschema: unsupported scalar type '${schemaName}'.`);\n    }\n    const val = await this.schemaResolver(schemaName);\n    if (!val) {\n      throw new Error(\n        `Picoschema: could not find schema with name '${schemaName}'`\n      );\n    }\n    return val;\n  }\n  async parse(schema) {\n    if (!schema) return null;\n    if (typeof schema === \"string\") {\n      const [type, description] = extractDescription(schema);\n      if (JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let out = { type };\n        if (description) out = { ...out, description };\n        return out;\n      }\n      const resolvedSchema = await this.mustResolveSchema(type);\n      return description ? { ...resolvedSchema, description } : resolvedSchema;\n    }\n    if ([...JSON_SCHEMA_SCALAR_TYPES, \"object\", \"array\"].includes(\n      schema?.type\n    )) {\n      return schema;\n    }\n    if (typeof schema?.properties === \"object\") {\n      return { ...schema, type: \"object\" };\n    }\n    return this.parsePico(schema);\n  }\n  async parsePico(obj, path = []) {\n    if (typeof obj === \"string\") {\n      const [type, description] = extractDescription(obj);\n      if (!JSON_SCHEMA_SCALAR_TYPES.includes(type)) {\n        let resolvedSchema = await this.mustResolveSchema(type);\n        if (description) resolvedSchema = { ...resolvedSchema, description };\n        return resolvedSchema;\n      }\n      if (type === \"any\") {\n        return description ? { description } : {};\n      }\n      return description ? { type, description } : { type };\n    } else if (typeof obj !== \"object\") {\n      throw new Error(\n        \"Picoschema: only consists of objects and strings. Got: \" + JSON.stringify(obj)\n      );\n    }\n    const schema = {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: false\n    };\n    for (const key in obj) {\n      if (key === WILDCARD_PROPERTY_NAME) {\n        schema.additionalProperties = await this.parsePico(obj[key], [\n          ...path,\n          key\n        ]);\n        continue;\n      }\n      const [name, typeInfo] = key.split(\"(\");\n      const isOptional = name.endsWith(\"?\");\n      const propertyName = isOptional ? name.slice(0, -1) : name;\n      if (!isOptional) {\n        schema.required.push(propertyName);\n      }\n      if (!typeInfo) {\n        const prop = { ...await this.parsePico(obj[key], [...path, key]) };\n        if (isOptional && typeof prop.type === \"string\") {\n          prop.type = [prop.type, \"null\"];\n        }\n        schema.properties[propertyName] = prop;\n        continue;\n      }\n      const [type, description] = extractDescription(\n        typeInfo.substring(0, typeInfo.length - 1)\n      );\n      if (type === \"array\") {\n        schema.properties[propertyName] = {\n          type: isOptional ? [\"array\", \"null\"] : \"array\",\n          items: await this.parsePico(obj[key], [...path, key])\n        };\n      } else if (type === \"object\") {\n        const prop = await this.parsePico(obj[key], [...path, key]);\n        if (isOptional) prop.type = [prop.type, \"null\"];\n        schema.properties[propertyName] = prop;\n      } else if (type === \"enum\") {\n        const prop = { enum: obj[key] };\n        if (isOptional && !prop.enum.includes(null)) prop.enum.push(null);\n        schema.properties[propertyName] = prop;\n      } else {\n        throw new Error(\n          \"Picoschema: parenthetical types must be 'object' or 'array', got: \" + type\n        );\n      }\n      if (description) {\n        schema.properties[propertyName].description = description;\n      }\n    }\n    if (!schema.required.length) delete schema.required;\n    return schema;\n  }\n};\nfunction extractDescription(input) {\n  if (!input.includes(\",\")) return [input, null];\n  const match = input.match(/(.*?), *(.*)$/);\n  return [match[1], match[2]];\n}\n\n// src/util.ts\nfunction removeUndefinedFields(obj) {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map((item) => removeUndefinedFields(item));\n  }\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (value !== void 0) {\n      result[key] = removeUndefinedFields(value);\n    }\n  }\n  return result;\n}\n\n// src/dotprompt.ts\nvar Dotprompt = class {\n  handlebars;\n  knownHelpers = {};\n  defaultModel;\n  modelConfigs = {};\n  tools = {};\n  toolResolver;\n  schemas = {};\n  schemaResolver;\n  partialResolver;\n  store;\n  constructor(options) {\n    this.handlebars = Handlebars.noConflict();\n    this.modelConfigs = options?.modelConfigs || this.modelConfigs;\n    this.defaultModel = options?.defaultModel;\n    this.tools = options?.tools || {};\n    this.toolResolver = options?.toolResolver;\n    this.schemas = options?.schemas || {};\n    this.schemaResolver = options?.schemaResolver;\n    this.partialResolver = options?.partialResolver;\n    for (const key in helpers_exports) {\n      this.defineHelper(key, helpers_exports[key]);\n      this.handlebars.registerHelper(key, helpers_exports[key]);\n    }\n    if (options?.helpers) {\n      for (const key in options.helpers) {\n        this.defineHelper(key, options.helpers[key]);\n      }\n    }\n    if (options?.partials) {\n      for (const key in options.partials) {\n        this.definePartial(key, options.partials[key]);\n      }\n    }\n  }\n  /**\n   * Registers a helper function for use in templates.\n   *\n   * @param name The name of the helper function to register\n   * @param fn The helper function implementation\n   * @return This instance for method chaining\n   */\n  defineHelper(name, fn) {\n    this.handlebars.registerHelper(name, fn);\n    this.knownHelpers[name] = true;\n    return this;\n  }\n  /**\n   * Registers a partial template for use in other templates.\n   *\n   * @param name The name of the partial to register\n   * @param source The template source for the partial\n   * @return This instance for method chaining\n   */\n  definePartial(name, source) {\n    this.handlebars.registerPartial(name, source);\n    return this;\n  }\n  /**\n   * Registers a tool definition for use in prompts.\n   *\n   * @param def The tool definition to register\n   * @return This instance for method chaining\n   */\n  defineTool(def) {\n    this.tools[def.name] = def;\n    return this;\n  }\n  /**\n   * Parses a prompt template string into a structured ParsedPrompt object.\n   *\n   * @param source The template source string to parse\n   * @return A parsed prompt object with extracted metadata and template\n   */\n  parse(source) {\n    return parseDocument(source);\n  }\n  /**\n   * Renders a prompt template with the provided data.\n   *\n   * @param source The template source string to render\n   * @param data The data to use when rendering the template\n   * @param options Additional metadata and options for rendering\n   * @return A promise resolving to the rendered prompt\n   */\n  async render(source, data = {}, options) {\n    const renderer = await this.compile(source);\n    return renderer(data, options);\n  }\n  /**\n   * Processes schema definitions in picoschema format into standard JSON Schema.\n   *\n   * @param meta The prompt metadata containing schema definitions\n   * @return A promise resolving to the processed metadata with expanded schemas\n   */\n  async renderPicoschema(meta) {\n    if (!meta.output?.schema && !meta.input?.schema) {\n      return meta;\n    }\n    const newMeta = { ...meta };\n    if (meta.input?.schema) {\n      newMeta.input = {\n        ...meta.input,\n        schema: await picoschema(meta.input.schema, {\n          schemaResolver: this.wrappedSchemaResolver.bind(this)\n        })\n      };\n    }\n    if (meta.output?.schema) {\n      newMeta.output = {\n        ...meta.output,\n        schema: await picoschema(meta.output.schema, {\n          schemaResolver: this.wrappedSchemaResolver.bind(this)\n        })\n      };\n    }\n    return newMeta;\n  }\n  /**\n   * Resolves a schema name to its definition, using registered schemas or schema resolver.\n   *\n   * @param name The name of the schema to resolve\n   * @return A promise resolving to the schema definition or null if not found\n   */\n  async wrappedSchemaResolver(name) {\n    if (this.schemas[name]) {\n      return this.schemas[name];\n    }\n    if (this.schemaResolver) {\n      return await this.schemaResolver(name);\n    }\n    return null;\n  }\n  /**\n   * Merges multiple metadata objects together, resolving tools and schemas.\n   *\n   * @param base The base metadata object\n   * @param merges Additional metadata objects to merge into the base\n   * @return A promise resolving to the merged and processed metadata\n   */\n  async resolveMetadata(base, ...merges) {\n    let out = { ...base };\n    for (let i = 0; i < merges.length; i++) {\n      if (!merges[i]) continue;\n      const config = out.config || {};\n      out = { ...out, ...merges[i] };\n      out.config = { ...config, ...merges[i]?.config || {} };\n    }\n    const { template: _, ...outWithoutTemplate } = out;\n    out = outWithoutTemplate;\n    out = removeUndefinedFields(out);\n    out = await this.resolveTools(out);\n    out = await this.renderPicoschema(out);\n    return out;\n  }\n  /**\n   * Resolves tool names to their definitions using registered tools or tool resolver.\n   *\n   * @param base The metadata containing tool references to resolve\n   * @return A promise resolving to metadata with resolved tool definitions\n   */\n  async resolveTools(base) {\n    const out = { ...base };\n    if (out.tools) {\n      const outTools = [];\n      out.toolDefs = out.toolDefs || [];\n      await Promise.all(\n        out.tools.map(async (toolName) => {\n          if (this.tools[toolName]) {\n            if (out.toolDefs) {\n              out.toolDefs.push(this.tools[toolName]);\n            }\n          } else if (this.toolResolver) {\n            const resolvedTool = await this.toolResolver(toolName);\n            if (!resolvedTool) {\n              throw new Error(\n                `Dotprompt: Unable to resolve tool '${toolName}' to a recognized tool definition.`\n              );\n            }\n            if (out.toolDefs) {\n              out.toolDefs.push(resolvedTool);\n            }\n          } else {\n            outTools.push(toolName);\n          }\n        })\n      );\n      out.tools = outTools;\n    }\n    return out;\n  }\n  /**\n   * Identifies all partial references in a template.\n   *\n   * @param template The template to scan for partial references\n   * @return A set of partial names referenced in the template\n   */\n  identifyPartials(template) {\n    const ast = this.handlebars.parse(template);\n    const partials = /* @__PURE__ */ new Set();\n    const visitor = new class extends this.handlebars.Visitor {\n      // Visit partial statements and add their names to our set.\n      PartialStatement(partial) {\n        if (partial && typeof partial === \"object\" && \"name\" in partial && partial.name && typeof partial.name === \"object\" && \"original\" in partial.name && typeof partial.name.original === \"string\") {\n          partials.add(partial.name.original);\n        }\n      }\n    }();\n    visitor.accept(ast);\n    return partials;\n  }\n  /**\n   * Resolves and registers all partials referenced in a template.\n   *\n   * @param template The template containing partial references\n   * @return A promise that resolves when all partials are registered\n   */\n  async resolvePartials(template) {\n    if (!this.partialResolver && !this.store) {\n      return;\n    }\n    const partials = this.identifyPartials(template);\n    await Promise.all(\n      Array.from(partials).map(async (name) => {\n        if (!this.handlebars.partials[name]) {\n          let content = null;\n          if (this.partialResolver) {\n            content = await this.partialResolver(name);\n          }\n          if (!content && this.store) {\n            const partial = await this.store.loadPartial(name);\n            content = partial?.source;\n          }\n          if (content) {\n            this.definePartial(name, content);\n            await this.resolvePartials(content);\n          }\n        }\n      })\n    );\n  }\n  /**\n   * Compiles a template into a reusable function for rendering prompts.\n   *\n   * @param source The template source or parsed prompt to compile\n   * @param additionalMetadata Additional metadata to include in the compiled template\n   * @return A promise resolving to a function for rendering the template\n   */\n  async compile(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    if (additionalMetadata) {\n      parsedSource = { ...parsedSource, ...additionalMetadata };\n    }\n    await this.resolvePartials(parsedSource.template);\n    const renderString = this.handlebars.compile(\n      parsedSource.template,\n      {\n        knownHelpers: this.knownHelpers,\n        knownHelpersOnly: true,\n        noEscape: true\n      }\n    );\n    const renderFunc = async (data, options) => {\n      const { input, ...mergedMetadata } = await this.renderMetadata(parsedSource);\n      const renderedString = renderString(\n        { ...options?.input?.default || {}, ...data.input },\n        {\n          data: {\n            metadata: {\n              prompt: mergedMetadata,\n              docs: data.docs,\n              messages: data.messages\n            },\n            ...data.context || {}\n          }\n        }\n      );\n      return {\n        ...mergedMetadata,\n        messages: toMessages(renderedString, data)\n      };\n    };\n    renderFunc.prompt = parsedSource;\n    return renderFunc;\n  }\n  /**\n   * Processes and resolves all metadata for a prompt template.\n   *\n   * @param source The template source or parsed prompt\n   * @param additionalMetadata Additional metadata to include\n   * @return A promise resolving to the fully processed metadata\n   */\n  async renderMetadata(source, additionalMetadata) {\n    let parsedSource;\n    if (typeof source === \"string\") {\n      parsedSource = this.parse(source);\n    } else {\n      parsedSource = source;\n    }\n    const selectedModel = additionalMetadata?.model || parsedSource.model || this.defaultModel;\n    let modelConfig;\n    if (selectedModel && this.modelConfigs[selectedModel]) {\n      modelConfig = this.modelConfigs[selectedModel];\n    }\n    return this.resolveMetadata(\n      modelConfig ? { config: modelConfig } : {},\n      parsedSource,\n      additionalMetadata\n    );\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG90cHJvbXB0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLGdFQUFZOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0IsbUJBQU8sQ0FBQyxnRUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsTUFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQixFQUFFLCtCQUErQix5QkFBeUIsT0FBTztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscURBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQSxVQUFVLGdDQUFnQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0IsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBSUwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0bi8uL25vZGVfbW9kdWxlcy9kb3Rwcm9tcHQvZGlzdC9pbmRleC5qcz9iN2RiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBEb3Rwcm9tcHQ6ICgpID0+IERvdHByb21wdCxcbiAgUGljb3NjaGVtYVBhcnNlcjogKCkgPT4gUGljb3NjaGVtYVBhcnNlcixcbiAgcGljb3NjaGVtYTogKCkgPT4gcGljb3NjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcblxuLy8gc3JjL2RvdHByb21wdC50c1xudmFyIEhhbmRsZWJhcnMgPSBfX3RvRVNNKHJlcXVpcmUoXCJoYW5kbGViYXJzXCIpKTtcblxuLy8gc3JjL2hlbHBlcnMudHNcbnZhciBoZWxwZXJzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGhlbHBlcnNfZXhwb3J0cywge1xuICBoaXN0b3J5OiAoKSA9PiBoaXN0b3J5LFxuICBpZkVxdWFsczogKCkgPT4gaWZFcXVhbHMsXG4gIGpzb246ICgpID0+IGpzb24sXG4gIG1lZGlhOiAoKSA9PiBtZWRpYSxcbiAgcm9sZTogKCkgPT4gcm9sZSxcbiAgc2VjdGlvbjogKCkgPT4gc2VjdGlvbixcbiAgdW5sZXNzRXF1YWxzOiAoKSA9PiB1bmxlc3NFcXVhbHNcbn0pO1xudmFyIGltcG9ydF9oYW5kbGViYXJzID0gcmVxdWlyZShcImhhbmRsZWJhcnNcIik7XG5mdW5jdGlvbiBqc29uKHNlcmlhbGl6YWJsZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IGltcG9ydF9oYW5kbGViYXJzLlNhZmVTdHJpbmcoXG4gICAgSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXphYmxlLCBudWxsLCBvcHRpb25zLmhhc2guaW5kZW50IHx8IDApXG4gICk7XG59XG5mdW5jdGlvbiByb2xlKHJvbGUyKSB7XG4gIHJldHVybiBuZXcgaW1wb3J0X2hhbmRsZWJhcnMuU2FmZVN0cmluZyhgPDw8ZG90cHJvbXB0OnJvbGU6JHtyb2xlMn0+Pj5gKTtcbn1cbmZ1bmN0aW9uIGhpc3RvcnkoKSB7XG4gIHJldHVybiBuZXcgaW1wb3J0X2hhbmRsZWJhcnMuU2FmZVN0cmluZyhcIjw8PGRvdHByb21wdDpoaXN0b3J5Pj4+XCIpO1xufVxuZnVuY3Rpb24gc2VjdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgaW1wb3J0X2hhbmRsZWJhcnMuU2FmZVN0cmluZyhgPDw8ZG90cHJvbXB0OnNlY3Rpb24gJHtuYW1lfT4+PmApO1xufVxuZnVuY3Rpb24gbWVkaWEob3B0aW9ucykge1xuICByZXR1cm4gbmV3IGltcG9ydF9oYW5kbGViYXJzLlNhZmVTdHJpbmcoXG4gICAgYDw8PGRvdHByb21wdDptZWRpYTp1cmwgJHtvcHRpb25zLmhhc2gudXJsfSR7b3B0aW9ucy5oYXNoLmNvbnRlbnRUeXBlID8gYCAke29wdGlvbnMuaGFzaC5jb250ZW50VHlwZX1gIDogXCJcIn0+Pj5gXG4gICk7XG59XG5mdW5jdGlvbiBpZkVxdWFscyhhcmcxLCBhcmcyLCBvcHRpb25zKSB7XG4gIHJldHVybiBhcmcxID09PSBhcmcyID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbn1cbmZ1bmN0aW9uIHVubGVzc0VxdWFscyhhcmcxLCBhcmcyLCBvcHRpb25zKSB7XG4gIHJldHVybiBhcmcxICE9PSBhcmcyID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbn1cblxuLy8gc3JjL3BhcnNlLnRzXG52YXIgaW1wb3J0X3lhbWwgPSByZXF1aXJlKFwieWFtbFwiKTtcbnZhciBST0xFX01BUktFUl9QUkVGSVggPSBcIjw8PGRvdHByb21wdDpyb2xlOlwiO1xudmFyIEhJU1RPUllfTUFSS0VSX1BSRUZJWCA9IFwiPDw8ZG90cHJvbXB0Omhpc3RvcnlcIjtcbnZhciBNRURJQV9NQVJLRVJfUFJFRklYID0gXCI8PDxkb3Rwcm9tcHQ6bWVkaWE6XCI7XG52YXIgU0VDVElPTl9NQVJLRVJfUFJFRklYID0gXCI8PDxkb3Rwcm9tcHQ6c2VjdGlvblwiO1xudmFyIEZST05UTUFUVEVSX0FORF9CT0RZX1JFR0VYID0gL14tLS1cXHMqXFxuKFtcXHNcXFNdKj8pXFxuLS0tXFxzKlxcbihbXFxzXFxTXSopJC87XG52YXIgUk9MRV9BTkRfSElTVE9SWV9NQVJLRVJfUkVHRVggPSAvKDw8PGRvdHByb21wdDooPzpyb2xlOlthLXpdK3xoaXN0b3J5KSk+Pj4vZztcbnZhciBNRURJQV9BTkRfU0VDVElPTl9NQVJLRVJfUkVHRVggPSAvKDw8PGRvdHByb21wdDooPzptZWRpYTp1cmx8c2VjdGlvbikuKj8pPj4+L2c7XG52YXIgUkVTRVJWRURfTUVUQURBVEFfS0VZV09SRFMgPSBbXG4gIC8vIE5PVEU6IEtFRVAgU09SVEVEXG4gIFwiY29uZmlnXCIsXG4gIFwiZGVzY3JpcHRpb25cIixcbiAgXCJleHRcIixcbiAgXCJpbnB1dFwiLFxuICBcIm1vZGVsXCIsXG4gIFwibmFtZVwiLFxuICBcIm91dHB1dFwiLFxuICBcInJhd1wiLFxuICBcInRvb2xEZWZzXCIsXG4gIFwidG9vbHNcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwidmVyc2lvblwiXG5dO1xudmFyIEJBU0VfTUVUQURBVEEgPSB7XG4gIGV4dDoge30sXG4gIG1ldGFkYXRhOiB7fSxcbiAgY29uZmlnOiB7fVxufTtcbmZ1bmN0aW9uIHNwbGl0QnlSZWdleChzb3VyY2UsIHJlZ2V4KSB7XG4gIHJldHVybiBzb3VyY2Uuc3BsaXQocmVnZXgpLmZpbHRlcigocykgPT4gcy50cmltKCkgIT09IFwiXCIpO1xufVxuZnVuY3Rpb24gc3BsaXRCeVJvbGVBbmRIaXN0b3J5TWFya2VycyhyZW5kZXJlZFN0cmluZykge1xuICByZXR1cm4gc3BsaXRCeVJlZ2V4KHJlbmRlcmVkU3RyaW5nLCBST0xFX0FORF9ISVNUT1JZX01BUktFUl9SRUdFWCk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5TWVkaWFBbmRTZWN0aW9uTWFya2Vycyhzb3VyY2UpIHtcbiAgcmV0dXJuIHNwbGl0QnlSZWdleChzb3VyY2UsIE1FRElBX0FORF9TRUNUSU9OX01BUktFUl9SRUdFWCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0TmFtZXNwYWNlZEVudHJ5VG9OZXN0ZWRPYmplY3Qoa2V5LCB2YWx1ZSwgb2JqID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gb2JqIHx8IHt9O1xuICBjb25zdCBsYXN0RG90SW5kZXggPSBrZXkubGFzdEluZGV4T2YoXCIuXCIpO1xuICBjb25zdCBucyA9IGtleS5zdWJzdHJpbmcoMCwgbGFzdERvdEluZGV4KTtcbiAgY29uc3QgZmllbGQgPSBrZXkuc3Vic3RyaW5nKGxhc3REb3RJbmRleCArIDEpO1xuICByZXN1bHRbbnNdID0gcmVzdWx0W25zXSB8fCB7fTtcbiAgcmVzdWx0W25zXVtmaWVsZF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGcm9udG1hdHRlckFuZEJvZHkoc291cmNlKSB7XG4gIGNvbnN0IG1hdGNoID0gc291cmNlLm1hdGNoKEZST05UTUFUVEVSX0FORF9CT0RZX1JFR0VYKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgWywgZnJvbnRtYXR0ZXIsIGJvZHldID0gbWF0Y2g7XG4gICAgcmV0dXJuIHsgZnJvbnRtYXR0ZXIsIGJvZHkgfTtcbiAgfVxuICByZXR1cm4geyBmcm9udG1hdHRlcjogXCJcIiwgYm9keTogXCJcIiB9O1xufVxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UpIHtcbiAgY29uc3QgeyBmcm9udG1hdHRlciwgYm9keSB9ID0gZXh0cmFjdEZyb250bWF0dGVyQW5kQm9keShzb3VyY2UpO1xuICBpZiAoZnJvbnRtYXR0ZXIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSAoMCwgaW1wb3J0X3lhbWwucGFyc2UpKGZyb250bWF0dGVyKTtcbiAgICAgIGNvbnN0IHJhdyA9IHsgLi4ucGFyc2VkTWV0YWRhdGEgfTtcbiAgICAgIGNvbnN0IHBydW5lZCA9IHsgLi4uQkFTRV9NRVRBREFUQSB9O1xuICAgICAgY29uc3QgZXh0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gcmF3KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgIGlmIChSRVNFUlZFRF9NRVRBREFUQV9LRVlXT1JEUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcHJ1bmVkW2tleV0gPSByYXdba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgY29udmVydE5hbWVzcGFjZWRFbnRyeVRvTmVzdGVkT2JqZWN0KGtleSwgcmF3W2tleV0sIGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLnBydW5lZCwgcmF3LCBleHQsIHRlbXBsYXRlOiBib2R5LnRyaW0oKSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRG90cHJvbXB0OiBFcnJvciBwYXJzaW5nIFlBTUwgZnJvbnRtYXR0ZXI6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IC4uLkJBU0VfTUVUQURBVEEsIHRlbXBsYXRlOiBzb3VyY2UudHJpbSgpIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IC4uLkJBU0VfTUVUQURBVEEsIHRlbXBsYXRlOiBzb3VyY2UgfTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VTb3VyY2VzVG9NZXNzYWdlcyhtZXNzYWdlU291cmNlcykge1xuICByZXR1cm4gbWVzc2FnZVNvdXJjZXMuZmlsdGVyKChtcykgPT4gbXMuY29udGVudCB8fCBtcy5zb3VyY2UpLm1hcCgobSkgPT4ge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIHJvbGU6IG0ucm9sZSxcbiAgICAgIGNvbnRlbnQ6IG0uY29udGVudCB8fCB0b1BhcnRzKG0uc291cmNlIHx8IFwiXCIpXG4gICAgfTtcbiAgICBpZiAobS5tZXRhZGF0YSkge1xuICAgICAgb3V0Lm1ldGFkYXRhID0gbS5tZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1NZXNzYWdlc1RvSGlzdG9yeShtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMubWFwKChtKSA9PiAoe1xuICAgIC4uLm0sXG4gICAgbWV0YWRhdGE6IHsgLi4ubS5tZXRhZGF0YSwgcHVycG9zZTogXCJoaXN0b3J5XCIgfVxuICB9KSk7XG59XG5mdW5jdGlvbiB0b01lc3NhZ2VzKHJlbmRlcmVkU3RyaW5nLCBkYXRhKSB7XG4gIGxldCBjdXJyZW50TWVzc2FnZSA9IHsgcm9sZTogXCJ1c2VyXCIsIHNvdXJjZTogXCJcIiB9O1xuICBjb25zdCBtZXNzYWdlU291cmNlcyA9IFtjdXJyZW50TWVzc2FnZV07XG4gIGZvciAoY29uc3QgcGllY2Ugb2Ygc3BsaXRCeVJvbGVBbmRIaXN0b3J5TWFya2VycyhyZW5kZXJlZFN0cmluZykpIHtcbiAgICBpZiAocGllY2Uuc3RhcnRzV2l0aChST0xFX01BUktFUl9QUkVGSVgpKSB7XG4gICAgICBjb25zdCByb2xlMiA9IHBpZWNlLnN1YnN0cmluZyhST0xFX01BUktFUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgIGlmIChjdXJyZW50TWVzc2FnZS5zb3VyY2U/LnRyaW0oKSkge1xuICAgICAgICBjdXJyZW50TWVzc2FnZSA9IHsgcm9sZTogcm9sZTIsIHNvdXJjZTogXCJcIiB9O1xuICAgICAgICBtZXNzYWdlU291cmNlcy5wdXNoKGN1cnJlbnRNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRNZXNzYWdlLnJvbGUgPSByb2xlMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBpZWNlLnN0YXJ0c1dpdGgoSElTVE9SWV9NQVJLRVJfUFJFRklYKSkge1xuICAgICAgY29uc3QgaGlzdG9yeU1lc3NhZ2VzID0gdHJhbnNmb3JtTWVzc2FnZXNUb0hpc3RvcnkoZGF0YT8ubWVzc2FnZXMgPz8gW10pO1xuICAgICAgaWYgKGhpc3RvcnlNZXNzYWdlcykge1xuICAgICAgICBtZXNzYWdlU291cmNlcy5wdXNoKC4uLmhpc3RvcnlNZXNzYWdlcyk7XG4gICAgICB9XG4gICAgICBjdXJyZW50TWVzc2FnZSA9IHsgcm9sZTogXCJtb2RlbFwiLCBzb3VyY2U6IFwiXCIgfTtcbiAgICAgIG1lc3NhZ2VTb3VyY2VzLnB1c2goY3VycmVudE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50TWVzc2FnZS5zb3VyY2UgKz0gcGllY2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZVNvdXJjZXNUb01lc3NhZ2VzKG1lc3NhZ2VTb3VyY2VzKTtcbiAgcmV0dXJuIGluc2VydEhpc3RvcnkobWVzc2FnZXMsIGRhdGE/Lm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VzSGF2ZUhpc3RvcnkobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLnNvbWUoKG0pID0+IG0ubWV0YWRhdGE/LnB1cnBvc2UgPT09IFwiaGlzdG9yeVwiKTtcbn1cbmZ1bmN0aW9uIGluc2VydEhpc3RvcnkobWVzc2FnZXMsIGhpc3RvcnkyID0gW10pIHtcbiAgaWYgKCFoaXN0b3J5MiB8fCBtZXNzYWdlc0hhdmVIaXN0b3J5KG1lc3NhZ2VzKSkge1xuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGhpc3RvcnkyO1xuICB9XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMuYXQoLTEpO1xuICBpZiAobGFzdE1lc3NhZ2U/LnJvbGUgPT09IFwidXNlclwiKSB7XG4gICAgY29uc3QgbWVzc2FnZXNXaXRob3V0TGFzdCA9IG1lc3NhZ2VzLnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gWy4uLm1lc3NhZ2VzV2l0aG91dExhc3QsIC4uLmhpc3RvcnkyLCBsYXN0TWVzc2FnZV07XG4gIH1cbiAgcmV0dXJuIFsuLi5tZXNzYWdlcywgLi4uaGlzdG9yeTJdO1xufVxuZnVuY3Rpb24gdG9QYXJ0cyhzb3VyY2UpIHtcbiAgcmV0dXJuIHNwbGl0QnlNZWRpYUFuZFNlY3Rpb25NYXJrZXJzKHNvdXJjZSkubWFwKHBhcnNlUGFydCk7XG59XG5mdW5jdGlvbiBwYXJzZVBhcnQocGllY2UpIHtcbiAgaWYgKHBpZWNlLnN0YXJ0c1dpdGgoTUVESUFfTUFSS0VSX1BSRUZJWCkpIHtcbiAgICByZXR1cm4gcGFyc2VNZWRpYVBhcnQocGllY2UpO1xuICB9IGVsc2UgaWYgKHBpZWNlLnN0YXJ0c1dpdGgoU0VDVElPTl9NQVJLRVJfUFJFRklYKSkge1xuICAgIHJldHVybiBwYXJzZVNlY3Rpb25QYXJ0KHBpZWNlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VUZXh0UGFydChwaWVjZSk7XG59XG5mdW5jdGlvbiBwYXJzZU1lZGlhUGFydChwaWVjZSkge1xuICBpZiAoIXBpZWNlLnN0YXJ0c1dpdGgoTUVESUFfTUFSS0VSX1BSRUZJWCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1lZGlhIHBpZWNlXCIpO1xuICB9XG4gIGNvbnN0IFtfLCB1cmwsIGNvbnRlbnRUeXBlXSA9IHBpZWNlLnNwbGl0KFwiIFwiKTtcbiAgY29uc3QgcGFydCA9IHsgbWVkaWE6IHsgdXJsIH0gfTtcbiAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgcGFydC5tZWRpYS5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIHJldHVybiBwYXJ0O1xufVxuZnVuY3Rpb24gcGFyc2VTZWN0aW9uUGFydChwaWVjZSkge1xuICBpZiAoIXBpZWNlLnN0YXJ0c1dpdGgoU0VDVElPTl9NQVJLRVJfUFJFRklYKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VjdGlvbiBwaWVjZVwiKTtcbiAgfVxuICBjb25zdCBbXywgc2VjdGlvblR5cGVdID0gcGllY2Uuc3BsaXQoXCIgXCIpO1xuICByZXR1cm4geyBtZXRhZGF0YTogeyBwdXJwb3NlOiBzZWN0aW9uVHlwZSwgcGVuZGluZzogdHJ1ZSB9IH07XG59XG5mdW5jdGlvbiBwYXJzZVRleHRQYXJ0KHBpZWNlKSB7XG4gIHJldHVybiB7IHRleHQ6IHBpZWNlIH07XG59XG5cbi8vIHNyYy9waWNvc2NoZW1hLnRzXG52YXIgSlNPTl9TQ0hFTUFfU0NBTEFSX1RZUEVTID0gW1xuICBcInN0cmluZ1wiLFxuICBcImJvb2xlYW5cIixcbiAgXCJudWxsXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwiaW50ZWdlclwiLFxuICBcImFueVwiXG5dO1xudmFyIFdJTERDQVJEX1BST1BFUlRZX05BTUUgPSBcIigqKVwiO1xuYXN5bmMgZnVuY3Rpb24gcGljb3NjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQaWNvc2NoZW1hUGFyc2VyKG9wdGlvbnMpLnBhcnNlKHNjaGVtYSk7XG59XG52YXIgUGljb3NjaGVtYVBhcnNlciA9IGNsYXNzIHtcbiAgc2NoZW1hUmVzb2x2ZXI7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNjaGVtYVJlc29sdmVyID0gb3B0aW9ucz8uc2NoZW1hUmVzb2x2ZXI7XG4gIH1cbiAgYXN5bmMgbXVzdFJlc29sdmVTY2hlbWEoc2NoZW1hTmFtZSkge1xuICAgIGlmICghdGhpcy5zY2hlbWFSZXNvbHZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQaWNvc2NoZW1hOiB1bnN1cHBvcnRlZCBzY2FsYXIgdHlwZSAnJHtzY2hlbWFOYW1lfScuYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IGF3YWl0IHRoaXMuc2NoZW1hUmVzb2x2ZXIoc2NoZW1hTmFtZSk7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBpY29zY2hlbWE6IGNvdWxkIG5vdCBmaW5kIHNjaGVtYSB3aXRoIG5hbWUgJyR7c2NoZW1hTmFtZX0nYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBhc3luYyBwYXJzZShzY2hlbWEpIHtcbiAgICBpZiAoIXNjaGVtYSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IFt0eXBlLCBkZXNjcmlwdGlvbl0gPSBleHRyYWN0RGVzY3JpcHRpb24oc2NoZW1hKTtcbiAgICAgIGlmIChKU09OX1NDSEVNQV9TQ0FMQVJfVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgbGV0IG91dCA9IHsgdHlwZSB9O1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIG91dCA9IHsgLi4ub3V0LCBkZXNjcmlwdGlvbiB9O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWRTY2hlbWEgPSBhd2FpdCB0aGlzLm11c3RSZXNvbHZlU2NoZW1hKHR5cGUpO1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uID8geyAuLi5yZXNvbHZlZFNjaGVtYSwgZGVzY3JpcHRpb24gfSA6IHJlc29sdmVkU2NoZW1hO1xuICAgIH1cbiAgICBpZiAoWy4uLkpTT05fU0NIRU1BX1NDQUxBUl9UWVBFUywgXCJvYmplY3RcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhcbiAgICAgIHNjaGVtYT8udHlwZVxuICAgICkpIHtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hPy5wcm9wZXJ0aWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4geyAuLi5zY2hlbWEsIHR5cGU6IFwib2JqZWN0XCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQaWNvKHNjaGVtYSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VQaWNvKG9iaiwgcGF0aCA9IFtdKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IFt0eXBlLCBkZXNjcmlwdGlvbl0gPSBleHRyYWN0RGVzY3JpcHRpb24ob2JqKTtcbiAgICAgIGlmICghSlNPTl9TQ0hFTUFfU0NBTEFSX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGxldCByZXNvbHZlZFNjaGVtYSA9IGF3YWl0IHRoaXMubXVzdFJlc29sdmVTY2hlbWEodHlwZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikgcmVzb2x2ZWRTY2hlbWEgPSB7IC4uLnJlc29sdmVkU2NoZW1hLCBkZXNjcmlwdGlvbiB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJhbnlcIikge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24gPyB7IGRlc2NyaXB0aW9uIH0gOiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbiA/IHsgdHlwZSwgZGVzY3JpcHRpb24gfSA6IHsgdHlwZSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlBpY29zY2hlbWE6IG9ubHkgY29uc2lzdHMgb2Ygb2JqZWN0cyBhbmQgc3RyaW5ncy4gR290OiBcIiArIEpTT04uc3RyaW5naWZ5KG9iailcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIHJlcXVpcmVkOiBbXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoa2V5ID09PSBXSUxEQ0FSRF9QUk9QRVJUWV9OQU1FKSB7XG4gICAgICAgIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGF3YWl0IHRoaXMucGFyc2VQaWNvKG9ialtrZXldLCBbXG4gICAgICAgICAgLi4ucGF0aCxcbiAgICAgICAgICBrZXlcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgW25hbWUsIHR5cGVJbmZvXSA9IGtleS5zcGxpdChcIihcIik7XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gbmFtZS5lbmRzV2l0aChcIj9cIik7XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBpc09wdGlvbmFsID8gbmFtZS5zbGljZSgwLCAtMSkgOiBuYW1lO1xuICAgICAgaWYgKCFpc09wdGlvbmFsKSB7XG4gICAgICAgIHNjaGVtYS5yZXF1aXJlZC5wdXNoKHByb3BlcnR5TmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSB7IC4uLmF3YWl0IHRoaXMucGFyc2VQaWNvKG9ialtrZXldLCBbLi4ucGF0aCwga2V5XSkgfTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdHlwZW9mIHByb3AudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHByb3AudHlwZSA9IFtwcm9wLnR5cGUsIFwibnVsbFwiXTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gcHJvcDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBbdHlwZSwgZGVzY3JpcHRpb25dID0gZXh0cmFjdERlc2NyaXB0aW9uKFxuICAgICAgICB0eXBlSW5mby5zdWJzdHJpbmcoMCwgdHlwZUluZm8ubGVuZ3RoIC0gMSlcbiAgICAgICk7XG4gICAgICBpZiAodHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogaXNPcHRpb25hbCA/IFtcImFycmF5XCIsIFwibnVsbFwiXSA6IFwiYXJyYXlcIixcbiAgICAgICAgICBpdGVtczogYXdhaXQgdGhpcy5wYXJzZVBpY28ob2JqW2tleV0sIFsuLi5wYXRoLCBrZXldKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBhd2FpdCB0aGlzLnBhcnNlUGljbyhvYmpba2V5XSwgWy4uLnBhdGgsIGtleV0pO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCkgcHJvcC50eXBlID0gW3Byb3AudHlwZSwgXCJudWxsXCJdO1xuICAgICAgICBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gcHJvcDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHsgZW51bTogb2JqW2tleV0gfTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgIXByb3AuZW51bS5pbmNsdWRlcyhudWxsKSkgcHJvcC5lbnVtLnB1c2gobnVsbCk7XG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiUGljb3NjaGVtYTogcGFyZW50aGV0aWNhbCB0eXBlcyBtdXN0IGJlICdvYmplY3QnIG9yICdhcnJheScsIGdvdDogXCIgKyB0eXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNjaGVtYS5yZXF1aXJlZC5sZW5ndGgpIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3REZXNjcmlwdGlvbihpbnB1dCkge1xuICBpZiAoIWlucHV0LmluY2x1ZGVzKFwiLFwiKSkgcmV0dXJuIFtpbnB1dCwgbnVsbF07XG4gIGNvbnN0IG1hdGNoID0gaW5wdXQubWF0Y2goLyguKj8pLCAqKC4qKSQvKTtcbiAgcmV0dXJuIFttYXRjaFsxXSwgbWF0Y2hbMl1dO1xufVxuXG4vLyBzcmMvdXRpbC50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRmllbGRzKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcCgoaXRlbSkgPT4gcmVtb3ZlVW5kZWZpbmVkRmllbGRzKGl0ZW0pKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHJlbW92ZVVuZGVmaW5lZEZpZWxkcyh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9kb3Rwcm9tcHQudHNcbnZhciBEb3Rwcm9tcHQgPSBjbGFzcyB7XG4gIGhhbmRsZWJhcnM7XG4gIGtub3duSGVscGVycyA9IHt9O1xuICBkZWZhdWx0TW9kZWw7XG4gIG1vZGVsQ29uZmlncyA9IHt9O1xuICB0b29scyA9IHt9O1xuICB0b29sUmVzb2x2ZXI7XG4gIHNjaGVtYXMgPSB7fTtcbiAgc2NoZW1hUmVzb2x2ZXI7XG4gIHBhcnRpYWxSZXNvbHZlcjtcbiAgc3RvcmU7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZWJhcnMgPSBIYW5kbGViYXJzLm5vQ29uZmxpY3QoKTtcbiAgICB0aGlzLm1vZGVsQ29uZmlncyA9IG9wdGlvbnM/Lm1vZGVsQ29uZmlncyB8fCB0aGlzLm1vZGVsQ29uZmlncztcbiAgICB0aGlzLmRlZmF1bHRNb2RlbCA9IG9wdGlvbnM/LmRlZmF1bHRNb2RlbDtcbiAgICB0aGlzLnRvb2xzID0gb3B0aW9ucz8udG9vbHMgfHwge307XG4gICAgdGhpcy50b29sUmVzb2x2ZXIgPSBvcHRpb25zPy50b29sUmVzb2x2ZXI7XG4gICAgdGhpcy5zY2hlbWFzID0gb3B0aW9ucz8uc2NoZW1hcyB8fCB7fTtcbiAgICB0aGlzLnNjaGVtYVJlc29sdmVyID0gb3B0aW9ucz8uc2NoZW1hUmVzb2x2ZXI7XG4gICAgdGhpcy5wYXJ0aWFsUmVzb2x2ZXIgPSBvcHRpb25zPy5wYXJ0aWFsUmVzb2x2ZXI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaGVscGVyc19leHBvcnRzKSB7XG4gICAgICB0aGlzLmRlZmluZUhlbHBlcihrZXksIGhlbHBlcnNfZXhwb3J0c1trZXldKTtcbiAgICAgIHRoaXMuaGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihrZXksIGhlbHBlcnNfZXhwb3J0c1trZXldKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmhlbHBlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuaGVscGVycykge1xuICAgICAgICB0aGlzLmRlZmluZUhlbHBlcihrZXksIG9wdGlvbnMuaGVscGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnBhcnRpYWxzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnBhcnRpYWxzKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lUGFydGlhbChrZXksIG9wdGlvbnMucGFydGlhbHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIHVzZSBpbiB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXJcbiAgICogQHBhcmFtIGZuIFRoZSBoZWxwZXIgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25cbiAgICogQHJldHVybiBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG4gIGRlZmluZUhlbHBlcihuYW1lLCBmbikge1xuICAgIHRoaXMuaGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lLCBmbik7XG4gICAgdGhpcy5rbm93bkhlbHBlcnNbbmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBwYXJ0aWFsIHRlbXBsYXRlIGZvciB1c2UgaW4gb3RoZXIgdGVtcGxhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFydGlhbCB0byByZWdpc3RlclxuICAgKiBAcGFyYW0gc291cmNlIFRoZSB0ZW1wbGF0ZSBzb3VyY2UgZm9yIHRoZSBwYXJ0aWFsXG4gICAqIEByZXR1cm4gVGhpcyBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuICBkZWZpbmVQYXJ0aWFsKG5hbWUsIHNvdXJjZSkge1xuICAgIHRoaXMuaGFuZGxlYmFycy5yZWdpc3RlclBhcnRpYWwobmFtZSwgc291cmNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgdG9vbCBkZWZpbml0aW9uIGZvciB1c2UgaW4gcHJvbXB0cy5cbiAgICpcbiAgICogQHBhcmFtIGRlZiBUaGUgdG9vbCBkZWZpbml0aW9uIHRvIHJlZ2lzdGVyXG4gICAqIEByZXR1cm4gVGhpcyBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuICBkZWZpbmVUb29sKGRlZikge1xuICAgIHRoaXMudG9vbHNbZGVmLm5hbWVdID0gZGVmO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBwcm9tcHQgdGVtcGxhdGUgc3RyaW5nIGludG8gYSBzdHJ1Y3R1cmVkIFBhcnNlZFByb21wdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHRlbXBsYXRlIHNvdXJjZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiBBIHBhcnNlZCBwcm9tcHQgb2JqZWN0IHdpdGggZXh0cmFjdGVkIG1ldGFkYXRhIGFuZCB0ZW1wbGF0ZVxuICAgKi9cbiAgcGFyc2Uoc291cmNlKSB7XG4gICAgcmV0dXJuIHBhcnNlRG9jdW1lbnQoc291cmNlKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBhIHByb21wdCB0ZW1wbGF0ZSB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFRoZSB0ZW1wbGF0ZSBzb3VyY2Ugc3RyaW5nIHRvIHJlbmRlclxuICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIHRlbXBsYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgbWV0YWRhdGEgYW5kIG9wdGlvbnMgZm9yIHJlbmRlcmluZ1xuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlbmRlcmVkIHByb21wdFxuICAgKi9cbiAgYXN5bmMgcmVuZGVyKHNvdXJjZSwgZGF0YSA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBhd2FpdCB0aGlzLmNvbXBpbGUoc291cmNlKTtcbiAgICByZXR1cm4gcmVuZGVyZXIoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBzY2hlbWEgZGVmaW5pdGlvbnMgaW4gcGljb3NjaGVtYSBmb3JtYXQgaW50byBzdGFuZGFyZCBKU09OIFNjaGVtYS5cbiAgICpcbiAgICogQHBhcmFtIG1ldGEgVGhlIHByb21wdCBtZXRhZGF0YSBjb250YWluaW5nIHNjaGVtYSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHByb2Nlc3NlZCBtZXRhZGF0YSB3aXRoIGV4cGFuZGVkIHNjaGVtYXNcbiAgICovXG4gIGFzeW5jIHJlbmRlclBpY29zY2hlbWEobWV0YSkge1xuICAgIGlmICghbWV0YS5vdXRwdXQ/LnNjaGVtYSAmJiAhbWV0YS5pbnB1dD8uc2NoZW1hKSB7XG4gICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG4gICAgY29uc3QgbmV3TWV0YSA9IHsgLi4ubWV0YSB9O1xuICAgIGlmIChtZXRhLmlucHV0Py5zY2hlbWEpIHtcbiAgICAgIG5ld01ldGEuaW5wdXQgPSB7XG4gICAgICAgIC4uLm1ldGEuaW5wdXQsXG4gICAgICAgIHNjaGVtYTogYXdhaXQgcGljb3NjaGVtYShtZXRhLmlucHV0LnNjaGVtYSwge1xuICAgICAgICAgIHNjaGVtYVJlc29sdmVyOiB0aGlzLndyYXBwZWRTY2hlbWFSZXNvbHZlci5iaW5kKHRoaXMpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobWV0YS5vdXRwdXQ/LnNjaGVtYSkge1xuICAgICAgbmV3TWV0YS5vdXRwdXQgPSB7XG4gICAgICAgIC4uLm1ldGEub3V0cHV0LFxuICAgICAgICBzY2hlbWE6IGF3YWl0IHBpY29zY2hlbWEobWV0YS5vdXRwdXQuc2NoZW1hLCB7XG4gICAgICAgICAgc2NoZW1hUmVzb2x2ZXI6IHRoaXMud3JhcHBlZFNjaGVtYVJlc29sdmVyLmJpbmQodGhpcylcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdNZXRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIHNjaGVtYSBuYW1lIHRvIGl0cyBkZWZpbml0aW9uLCB1c2luZyByZWdpc3RlcmVkIHNjaGVtYXMgb3Igc2NoZW1hIHJlc29sdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2NoZW1hIHRvIHJlc29sdmVcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzY2hlbWEgZGVmaW5pdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgd3JhcHBlZFNjaGVtYVJlc29sdmVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlbWFzW25hbWVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zY2hlbWFSZXNvbHZlcikge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2NoZW1hUmVzb2x2ZXIobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgbXVsdGlwbGUgbWV0YWRhdGEgb2JqZWN0cyB0b2dldGhlciwgcmVzb2x2aW5nIHRvb2xzIGFuZCBzY2hlbWFzLlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZSBUaGUgYmFzZSBtZXRhZGF0YSBvYmplY3RcbiAgICogQHBhcmFtIG1lcmdlcyBBZGRpdGlvbmFsIG1ldGFkYXRhIG9iamVjdHMgdG8gbWVyZ2UgaW50byB0aGUgYmFzZVxuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lcmdlZCBhbmQgcHJvY2Vzc2VkIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyByZXNvbHZlTWV0YWRhdGEoYmFzZSwgLi4ubWVyZ2VzKSB7XG4gICAgbGV0IG91dCA9IHsgLi4uYmFzZSB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW1lcmdlc1tpXSkgY29udGludWU7XG4gICAgICBjb25zdCBjb25maWcgPSBvdXQuY29uZmlnIHx8IHt9O1xuICAgICAgb3V0ID0geyAuLi5vdXQsIC4uLm1lcmdlc1tpXSB9O1xuICAgICAgb3V0LmNvbmZpZyA9IHsgLi4uY29uZmlnLCAuLi5tZXJnZXNbaV0/LmNvbmZpZyB8fCB7fSB9O1xuICAgIH1cbiAgICBjb25zdCB7IHRlbXBsYXRlOiBfLCAuLi5vdXRXaXRob3V0VGVtcGxhdGUgfSA9IG91dDtcbiAgICBvdXQgPSBvdXRXaXRob3V0VGVtcGxhdGU7XG4gICAgb3V0ID0gcmVtb3ZlVW5kZWZpbmVkRmllbGRzKG91dCk7XG4gICAgb3V0ID0gYXdhaXQgdGhpcy5yZXNvbHZlVG9vbHMob3V0KTtcbiAgICBvdXQgPSBhd2FpdCB0aGlzLnJlbmRlclBpY29zY2hlbWEob3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0b29sIG5hbWVzIHRvIHRoZWlyIGRlZmluaXRpb25zIHVzaW5nIHJlZ2lzdGVyZWQgdG9vbHMgb3IgdG9vbCByZXNvbHZlci5cbiAgICpcbiAgICogQHBhcmFtIGJhc2UgVGhlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdG9vbCByZWZlcmVuY2VzIHRvIHJlc29sdmVcbiAgICogQHJldHVybiBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG1ldGFkYXRhIHdpdGggcmVzb2x2ZWQgdG9vbCBkZWZpbml0aW9uc1xuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZVRvb2xzKGJhc2UpIHtcbiAgICBjb25zdCBvdXQgPSB7IC4uLmJhc2UgfTtcbiAgICBpZiAob3V0LnRvb2xzKSB7XG4gICAgICBjb25zdCBvdXRUb29scyA9IFtdO1xuICAgICAgb3V0LnRvb2xEZWZzID0gb3V0LnRvb2xEZWZzIHx8IFtdO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG91dC50b29scy5tYXAoYXN5bmMgKHRvb2xOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMudG9vbHNbdG9vbE5hbWVdKSB7XG4gICAgICAgICAgICBpZiAob3V0LnRvb2xEZWZzKSB7XG4gICAgICAgICAgICAgIG91dC50b29sRGVmcy5wdXNoKHRoaXMudG9vbHNbdG9vbE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9vbFJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFRvb2wgPSBhd2FpdCB0aGlzLnRvb2xSZXNvbHZlcih0b29sTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkVG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYERvdHByb21wdDogVW5hYmxlIHRvIHJlc29sdmUgdG9vbCAnJHt0b29sTmFtZX0nIHRvIGEgcmVjb2duaXplZCB0b29sIGRlZmluaXRpb24uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dC50b29sRGVmcykge1xuICAgICAgICAgICAgICBvdXQudG9vbERlZnMucHVzaChyZXNvbHZlZFRvb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRUb29scy5wdXNoKHRvb2xOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgb3V0LnRvb2xzID0gb3V0VG9vbHM7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIElkZW50aWZpZXMgYWxsIHBhcnRpYWwgcmVmZXJlbmNlcyBpbiBhIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGUgVGhlIHRlbXBsYXRlIHRvIHNjYW4gZm9yIHBhcnRpYWwgcmVmZXJlbmNlc1xuICAgKiBAcmV0dXJuIEEgc2V0IG9mIHBhcnRpYWwgbmFtZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGVcbiAgICovXG4gIGlkZW50aWZ5UGFydGlhbHModGVtcGxhdGUpIHtcbiAgICBjb25zdCBhc3QgPSB0aGlzLmhhbmRsZWJhcnMucGFyc2UodGVtcGxhdGUpO1xuICAgIGNvbnN0IHBhcnRpYWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IGNsYXNzIGV4dGVuZHMgdGhpcy5oYW5kbGViYXJzLlZpc2l0b3Ige1xuICAgICAgLy8gVmlzaXQgcGFydGlhbCBzdGF0ZW1lbnRzIGFuZCBhZGQgdGhlaXIgbmFtZXMgdG8gb3VyIHNldC5cbiAgICAgIFBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbCkge1xuICAgICAgICBpZiAocGFydGlhbCAmJiB0eXBlb2YgcGFydGlhbCA9PT0gXCJvYmplY3RcIiAmJiBcIm5hbWVcIiBpbiBwYXJ0aWFsICYmIHBhcnRpYWwubmFtZSAmJiB0eXBlb2YgcGFydGlhbC5uYW1lID09PSBcIm9iamVjdFwiICYmIFwib3JpZ2luYWxcIiBpbiBwYXJ0aWFsLm5hbWUgJiYgdHlwZW9mIHBhcnRpYWwubmFtZS5vcmlnaW5hbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhcnRpYWxzLmFkZChwYXJ0aWFsLm5hbWUub3JpZ2luYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICAgIHZpc2l0b3IuYWNjZXB0KGFzdCk7XG4gICAgcmV0dXJuIHBhcnRpYWxzO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhbmQgcmVnaXN0ZXJzIGFsbCBwYXJ0aWFscyByZWZlcmVuY2VkIGluIGEgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgY29udGFpbmluZyBwYXJ0aWFsIHJlZmVyZW5jZXNcbiAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBwYXJ0aWFscyBhcmUgcmVnaXN0ZXJlZFxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZVBhcnRpYWxzKHRlbXBsYXRlKSB7XG4gICAgaWYgKCF0aGlzLnBhcnRpYWxSZXNvbHZlciAmJiAhdGhpcy5zdG9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWFscyA9IHRoaXMuaWRlbnRpZnlQYXJ0aWFscyh0ZW1wbGF0ZSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKHBhcnRpYWxzKS5tYXAoYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZWJhcnMucGFydGlhbHNbbmFtZV0pIHtcbiAgICAgICAgICBsZXQgY29udGVudCA9IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMucGFydGlhbFJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gYXdhaXQgdGhpcy5wYXJ0aWFsUmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29udGVudCAmJiB0aGlzLnN0b3JlKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsID0gYXdhaXQgdGhpcy5zdG9yZS5sb2FkUGFydGlhbChuYW1lKTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJ0aWFsPy5zb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZVBhcnRpYWwobmFtZSwgY29udGVudCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmVQYXJ0aWFscyhjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZXMgYSB0ZW1wbGF0ZSBpbnRvIGEgcmV1c2FibGUgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBwcm9tcHRzLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFRoZSB0ZW1wbGF0ZSBzb3VyY2Ugb3IgcGFyc2VkIHByb21wdCB0byBjb21waWxlXG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsTWV0YWRhdGEgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBpbmNsdWRlIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHRoZSB0ZW1wbGF0ZVxuICAgKi9cbiAgYXN5bmMgY29tcGlsZShzb3VyY2UsIGFkZGl0aW9uYWxNZXRhZGF0YSkge1xuICAgIGxldCBwYXJzZWRTb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHRoaXMucGFyc2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoYWRkaXRpb25hbE1ldGFkYXRhKSB7XG4gICAgICBwYXJzZWRTb3VyY2UgPSB7IC4uLnBhcnNlZFNvdXJjZSwgLi4uYWRkaXRpb25hbE1ldGFkYXRhIH07XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzb2x2ZVBhcnRpYWxzKHBhcnNlZFNvdXJjZS50ZW1wbGF0ZSk7XG4gICAgY29uc3QgcmVuZGVyU3RyaW5nID0gdGhpcy5oYW5kbGViYXJzLmNvbXBpbGUoXG4gICAgICBwYXJzZWRTb3VyY2UudGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIGtub3duSGVscGVyczogdGhpcy5rbm93bkhlbHBlcnMsXG4gICAgICAgIGtub3duSGVscGVyc09ubHk6IHRydWUsXG4gICAgICAgIG5vRXNjYXBlOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCByZW5kZXJGdW5jID0gYXN5bmMgKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXQsIC4uLm1lcmdlZE1ldGFkYXRhIH0gPSBhd2FpdCB0aGlzLnJlbmRlck1ldGFkYXRhKHBhcnNlZFNvdXJjZSk7XG4gICAgICBjb25zdCByZW5kZXJlZFN0cmluZyA9IHJlbmRlclN0cmluZyhcbiAgICAgICAgeyAuLi5vcHRpb25zPy5pbnB1dD8uZGVmYXVsdCB8fCB7fSwgLi4uZGF0YS5pbnB1dCB9LFxuICAgICAgICB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgcHJvbXB0OiBtZXJnZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgZG9jczogZGF0YS5kb2NzLFxuICAgICAgICAgICAgICBtZXNzYWdlczogZGF0YS5tZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLmRhdGEuY29udGV4dCB8fCB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlZE1ldGFkYXRhLFxuICAgICAgICBtZXNzYWdlczogdG9NZXNzYWdlcyhyZW5kZXJlZFN0cmluZywgZGF0YSlcbiAgICAgIH07XG4gICAgfTtcbiAgICByZW5kZXJGdW5jLnByb21wdCA9IHBhcnNlZFNvdXJjZTtcbiAgICByZXR1cm4gcmVuZGVyRnVuYztcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGFuZCByZXNvbHZlcyBhbGwgbWV0YWRhdGEgZm9yIGEgcHJvbXB0IHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIFRoZSB0ZW1wbGF0ZSBzb3VyY2Ugb3IgcGFyc2VkIHByb21wdFxuICAgKiBAcGFyYW0gYWRkaXRpb25hbE1ldGFkYXRhIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gaW5jbHVkZVxuICAgKiBAcmV0dXJuIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGZ1bGx5IHByb2Nlc3NlZCBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVuZGVyTWV0YWRhdGEoc291cmNlLCBhZGRpdGlvbmFsTWV0YWRhdGEpIHtcbiAgICBsZXQgcGFyc2VkU291cmNlO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXJzZWRTb3VyY2UgPSB0aGlzLnBhcnNlKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRNb2RlbCA9IGFkZGl0aW9uYWxNZXRhZGF0YT8ubW9kZWwgfHwgcGFyc2VkU291cmNlLm1vZGVsIHx8IHRoaXMuZGVmYXVsdE1vZGVsO1xuICAgIGxldCBtb2RlbENvbmZpZztcbiAgICBpZiAoc2VsZWN0ZWRNb2RlbCAmJiB0aGlzLm1vZGVsQ29uZmlnc1tzZWxlY3RlZE1vZGVsXSkge1xuICAgICAgbW9kZWxDb25maWcgPSB0aGlzLm1vZGVsQ29uZmlnc1tzZWxlY3RlZE1vZGVsXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZU1ldGFkYXRhKFxuICAgICAgbW9kZWxDb25maWcgPyB7IGNvbmZpZzogbW9kZWxDb25maWcgfSA6IHt9LFxuICAgICAgcGFyc2VkU291cmNlLFxuICAgICAgYWRkaXRpb25hbE1ldGFkYXRhXG4gICAgKTtcbiAgfVxufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBEb3Rwcm9tcHQsXG4gIFBpY29zY2hlbWFQYXJzZXIsXG4gIHBpY29zY2hlbWFcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dotprompt/dist/index.js\n");

/***/ })

};
;